
ğŸ“‹ DOCUMENTO TÃ‰CNICO: MÃ“DULO HELPDESK

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“‘ INFORMACIÃ“N DEL DOCUMENTO

| Campo          | Valor                                           |
|---------------|-------------------------------------------------|
| **Documento** | EspecificaciÃ³n TÃ©cnica - MÃ³dulo HELPDESK      |
| **VersiÃ³n**   | 1.0                                            |
| **Fecha**     | 28 de Julio, 2025                              |
| **Autor**     | GitHub Copilot                                 |
| **Proyecto**  | Sistema de GestiÃ³n de Casos - case-management-react |
| **Estado**    | EspecificaciÃ³n - No Implementado               |
| **Revisor**   | Equipo de Desarrollo                           |
| **AprobaciÃ³n**| Pendiente                                      |

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ 1. RESUMEN EJECUTIVO

1.1 PropÃ³sito

El mÃ³dulo HELPDESK representa una evoluciÃ³n estratÃ©gica del sistema de gestiÃ³n de casos existente, introduciendo un sistema de tickets con chat en tiempo real que servirÃ¡ como **punto de entrada unificado** para todas las solicitudes de soporte y servicios. Este mÃ³dulo transformarÃ¡ fundamentalmente el flujo operativo actual, convirtiendo el mÃ³dulo "Nuevo Caso" en un **clasificador especializado** que procesa y categoriza los tickets del HELPDESK.

**Objetivos EstratÃ©gicos:**
- **CentralizaciÃ³n de Solicitudes**: Unificar todos los canales de comunicaciÃ³n en una sola plataforma
- **Mejora en SLA**: Implementar controles rigurosos de tiempo de respuesta y resoluciÃ³n
- **AutomatizaciÃ³n Inteligente**: Reducir intervenciÃ³n manual mediante algoritmos de asignaciÃ³n y escalaciÃ³n
- **Visibilidad Operacional**: Proporcionar mÃ©tricas en tiempo real para la toma de decisiones

1.2 Alcance del Proyecto

**âœ… INCLUIDO EN EL ALCANCE:**

**MÃ³dulo de Tickets:**
- Sistema completo de tickets con numeraciÃ³n automÃ¡tica (HD-YYYY-NNNNNN)
- Chat en tiempo real con soporte multi-usuario
- GestiÃ³n de estados del ciclo de vida completo
- Sistema de prioridades y categorizaciÃ³n
- Tracking de SLA con alertas automÃ¡ticas

**Dashboard Especializado:**
- MÃ©tricas de SLA y ANS en tiempo real
- Widgets personalizables por rol
- Reportes de performance de agentes
- AnÃ¡lisis de tendencias y patrones
- Alertas de incumplimiento de SLA

**Sistema de Roles y Permisos:**
- 8 nuevos roles especializados (Customer, Agent L1-L3, Supervisor, Team Lead, Manager, Escalation Analyst)
- 25+ permisos granulares especÃ­ficos para HELPDESK
- Row Level Security (RLS) implementado en PostgreSQL
- Matriz de permisos configurable

**IntegraciÃ³n con MÃ³dulos Existentes:**
- SincronizaciÃ³n bidireccional con mÃ³dulo de Casos
- IntegraciÃ³n con sistema de TODOs
- Aprovechamiento de infraestructura de usuarios y roles actual
- API de integraciÃ³n para sistemas externos

**AutomatizaciÃ³n y IA:**
- Motor de auto-asignaciÃ³n configurable
- Sistema de escalaciÃ³n automÃ¡tica
- CÃ¡lculo dinÃ¡mico de SLA
- AnÃ¡lisis de patrones de tickets

**âœ… FUNCIONALIDADES PRINCIPALES:**

1. **Chat en Tiempo Real**
   - Mensajes instantÃ¡neos con WebSockets
   - Soporte para archivos adjuntos (hasta 10MB)
   - Indicadores de escritura y estado de mensajes
   - Notas internas solo para agentes
   - Historial completo de conversaciones

2. **GestiÃ³n de SLA**
   - ConfiguraciÃ³n flexible por prioridad y categorÃ­a
   - Tracking automÃ¡tico de tiempo de primera respuesta
   - Monitoreo de tiempo de resoluciÃ³n
   - Alertas preventivas antes de incumplimiento
   - Reportes de cumplimiento detallados

3. **Sistema de EscalaciÃ³n**
   - Reglas configurables de escalaciÃ³n automÃ¡tica
   - EscalaciÃ³n manual entre niveles
   - Notificaciones automÃ¡ticas a supervisores
   - Tracking de cadena de escalaciÃ³n
   - AnÃ¡lisis de causas de escalaciÃ³n

4. **Dashboard y Reportes**
   - Vista en tiempo real de mÃ©tricas clave
   - Filtros avanzados por perÃ­odo, agente, categorÃ­a
   - ExportaciÃ³n de reportes en mÃºltiples formatos
   - AnÃ¡lisis de satisfacciÃ³n del cliente
   - Trending de volumen y performance

5. **IntegraciÃ³n Inteligente**
   - ConversiÃ³n automÃ¡tica de tickets a casos
   - ClasificaciÃ³n de complejidad asistida por IA
   - SincronizaciÃ³n de estados cross-mÃ³dulo
   - API REST completa para integraciones

**âŒ EXCLUIDO DEL ALCANCE:**

- IntegraciÃ³n con sistemas telefÃ³nicos (PBX)
- Chatbots con AI conversacional avanzada
- IntegraciÃ³n con WhatsApp Business (fase futura)
- Sistema de facturaciÃ³n integrado
- MÃ³dulo de knowledge base completo (solo bÃ¡sico)
- IntegraciÃ³n con herramientas de monitoreo externas

**ğŸ¯ BENEFICIOS ESPERADOS:**

**Para el Negocio:**
- **â†—ï¸ +40% mejora** en tiempo de primera respuesta
- **â†—ï¸ +35% aumento** en satisfacciÃ³n del cliente
- **â†˜ï¸ -50% reducciÃ³n** en tickets escalados por SLA
- **â†—ï¸ +60% incremento** en visibilidad operacional

**Para los Agentes:**
- **â†˜ï¸ -30% reducciÃ³n** en tiempo de clasificaciÃ³n de casos
- **â†—ï¸ +45% mejora** en eficiencia de asignaciÃ³n
- **â†—ï¸ +25% incremento** en productividad por automatizaciÃ³n
- **â†—ï¸ +80% mejora** en acceso a informaciÃ³n contextual

**Para los Clientes:**
- **â†—ï¸ +90% mejora** en tiempo de respuesta inicial
- **â†—ï¸ +70% incremento** en transparencia del proceso
- **â†—ï¸ +60% mejora** en experiencia general
- **â†˜ï¸ -40% reducciÃ³n** en seguimientos innecesarios

1.3 Objetivos TÃ©cnicos

**Objetivos de Performance:**
- Tiempo de respuesta del chat < 100ms
- Disponibilidad del sistema > 99.5%
- Soporte para 100+ usuarios concurrentes
- Capacidad de procesamiento de 1000+ tickets/dÃ­a

**Objetivos de Escalabilidad:**
- Arquitectura modular que permita crecimiento horizontal
- Base de datos optimizada para millones de tickets
- Sistema de cachÃ© para mÃ©tricas en tiempo real
- API rate limiting para prevenir abuso

**Objetivos de Mantenibilidad:**
- Cobertura de pruebas > 85%
- DocumentaciÃ³n tÃ©cnica completa
- Logs estructurados para debugging
- Monitoreo proactivo de salud del sistema

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ—ï¸ 2. ARQUITECTURA DEL SISTEMA

2.1 Arquitectura General

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    FRONTEND (React + TypeScript)            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  ğŸ“± Chat Interface  â”‚  ğŸ“Š Dashboard  â”‚  ğŸ›ï¸ Admin Panel    â”‚
â”‚  ğŸ« Ticket List     â”‚  ğŸ“ˆ Reports    â”‚  âš™ï¸ Configuration  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    ESTADO GLOBAL (Zustand)                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    CAPA DE SERVICIOS                        â”‚
â”‚  ğŸ”„ SLA Service  â”‚  ğŸ“¨ Chat Service  â”‚  ğŸš¨ Escalation     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                    SUPABASE (Backend as a Service)          â”‚
â”‚  ğŸ—„ï¸ PostgreSQL   â”‚  ğŸ” Auth        â”‚  ğŸ“¡ Realtime       â”‚
â”‚  ğŸ“ Storage      â”‚  ğŸ›¡ï¸ RLS         â”‚  ğŸ”Œ API            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

2.2 Patrones de Arquitectura Utilizados

- **MVC (Model-View-Controller)**: SeparaciÃ³n clara entre datos, vista y lÃ³gica
- **Pub/Sub**: Para comunicaciÃ³n en tiempo real via Supabase Realtime
- **Repository Pattern**: Para abstracciÃ³n de acceso a datos
- **Observer Pattern**: Para actualizaciones reactivas de estado
- **Strategy Pattern**: Para diferentes algoritmos de asignaciÃ³n y escalaciÃ³n

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ—„ï¸ 3. DISEÃ‘O DE BASE DE DATOS

3.1 Diagrama ERD

```
helpdesk_tickets  â†â†’  helpdesk_chat_messages
       â†“
helpdesk_sla_tracking
       â†“
helpdesk_escalations
       â†“
helpdesk_case_link  â†â†’  cases (mÃ³dulo existente)
```

3.2 Tablas Principales

3.2.1 helpdesk_tickets
```sql
CREATE TABLE helpdesk_tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_number VARCHAR(20) UNIQUE NOT NULL, -- HD-2025-001
    subject VARCHAR(255) NOT NULL,
    description TEXT,
    priority_id UUID REFERENCES helpdesk_priorities(id),
    category_id UUID REFERENCES helpdesk_categories(id),
    status_id UUID REFERENCES helpdesk_statuses(id),
    requester_user_id UUID REFERENCES user_profiles(id),
    assigned_agent_id UUID REFERENCES user_profiles(id),
    escalated_to_user_id UUID REFERENCES user_profiles(id),
    channel_id UUID REFERENCES helpdesk_channels(id),
    source_type VARCHAR(50) DEFAULT 'chat',
    severity_level INTEGER DEFAULT 3 CHECK (severity_level BETWEEN 1 AND 5),
    impact_level INTEGER DEFAULT 3 CHECK (impact_level BETWEEN 1 AND 5),
    urgency_level INTEGER DEFAULT 3 CHECK (urgency_level BETWEEN 1 AND 5),
    sla_due_date TIMESTAMP,
    first_response_at TIMESTAMP,
    resolution_date TIMESTAMP,
    satisfaction_rating INTEGER CHECK (satisfaction_rating BETWEEN 1 AND 5),
    satisfaction_comment TEXT,
    tags JSONB DEFAULT '[]',
    custom_fields JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now(),
    closed_at TIMESTAMP
);

-- Ãndices para optimizaciÃ³n
CREATE INDEX idx_helpdesk_tickets_status ON helpdesk_tickets(status_id);
CREATE INDEX idx_helpdesk_tickets_assigned ON helpdesk_tickets(assigned_agent_id);
CREATE INDEX idx_helpdesk_tickets_requester ON helpdesk_tickets(requester_user_id);
CREATE INDEX idx_helpdesk_tickets_sla_due ON helpdesk_tickets(sla_due_date);
CREATE INDEX idx_helpdesk_tickets_created ON helpdesk_tickets(created_at);
```

3.2.2 helpdesk_chat_messages
```sql
CREATE TABLE helpdesk_chat_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID REFERENCES helpdesk_tickets(id) ON DELETE CASCADE,
    sender_user_id UUID REFERENCES user_profiles(id),
    message_type VARCHAR(50) DEFAULT 'text' CHECK (message_type IN ('text', 'image', 'file', 'system')),
    content TEXT NOT NULL,
    attachments JSONB DEFAULT '[]',
    is_internal BOOLEAN DEFAULT false,
    is_system_message BOOLEAN DEFAULT false,
    edited_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT now()
);

-- Ãndices
CREATE INDEX idx_chat_messages_ticket ON helpdesk_chat_messages(ticket_id, created_at);
CREATE INDEX idx_chat_messages_sender ON helpdesk_chat_messages(sender_user_id);
```

3.2.3 helpdesk_sla_tracking
```sql
CREATE TABLE helpdesk_sla_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID REFERENCES helpdesk_tickets(id) ON DELETE CASCADE,
    sla_type VARCHAR(50) NOT NULL CHECK (sla_type IN ('first_response', 'resolution')),
    target_date TIMESTAMP NOT NULL,
    achieved_date TIMESTAMP,
    is_breached BOOLEAN DEFAULT false,
    breach_time_minutes INTEGER DEFAULT 0,
    escalation_triggered BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now()
);
```

3.3 Funciones y Triggers

3.3.1 FunciÃ³n para generar nÃºmero de ticket
```sql
CREATE OR REPLACE FUNCTION generate_ticket_number()
RETURNS TEXT AS $$
DECLARE
    year_part TEXT;
    sequence_part TEXT;
    result TEXT;
BEGIN
    year_part := EXTRACT(YEAR FROM NOW())::TEXT;
    
    SELECT LPAD((COUNT(*) + 1)::TEXT, 6, '0') INTO sequence_part
    FROM helpdesk_tickets 
    WHERE EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM NOW());
    
    result := 'HD-' || year_part || '-' || sequence_part;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

3.3.2 Trigger para auto-generar nÃºmero de ticket
```sql
CREATE OR REPLACE FUNCTION set_ticket_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.ticket_number IS NULL THEN
        NEW.ticket_number := generate_ticket_number();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_ticket_number
    BEFORE INSERT ON helpdesk_tickets
    FOR EACH ROW EXECUTE FUNCTION set_ticket_number();
```

3.3.3 FunciÃ³n para calcular SLA
```sql
CREATE OR REPLACE FUNCTION calculate_sla_dates(
    p_priority_id UUID,
    p_category_id UUID,
    p_created_at TIMESTAMP DEFAULT NOW()
)
RETURNS TABLE(
    first_response_due TIMESTAMP,
    resolution_due TIMESTAMP
) AS $$
DECLARE
    priority_response_hours INTEGER;
    priority_resolution_hours INTEGER;
    category_modifier DECIMAL(5,2);
BEGIN
    -- Obtener tiempos SLA de la prioridad
    SELECT 
        hp.sla_response_hours,
        hp.sla_resolution_hours
    INTO priority_response_hours, priority_resolution_hours
    FROM helpdesk_priorities hp
    WHERE hp.id = p_priority_id;
    
    -- Obtener modificador de categorÃ­a
    SELECT COALESCE(hc.sla_modifier_percentage, 100.00) / 100.0
    INTO category_modifier
    FROM helpdesk_categories hc
    WHERE hc.id = p_category_id;
    
    -- Calcular fechas SLA
    first_response_due := p_created_at + 
        INTERVAL '1 hour' * (priority_response_hours * category_modifier);
    
    resolution_due := p_created_at + 
        INTERVAL '1 hour' * (priority_resolution_hours * category_modifier);
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¨ 4. DISEÃ‘O DE INTERFAZ DE USUARIO

4.1 Componentes Principales

4.1.1 Chat Interface
```typescript
interface ChatInterfaceProps {
    ticketId: string;
    currentUser: User;
    onSendMessage: (message: string, attachments?: File[]) => void;
    onTyping: (isTyping: boolean) => void;
}

interface ChatInterfaceState {
    messages: ChatMessage[];
    isTyping: boolean;
    typingUsers: User[];
    showInternalNotes: boolean;
    attachmentPreview?: File;
}
```

CaracterÃ­sticas tÃ©cnicas:
- **WebSocket Connection**: Supabase Realtime para mensajes en tiempo real
- **Typing Indicators**: Indicadores de escritura
- **Message Status**: Estados de mensaje (enviado, entregado, leÃ­do)
- **File Upload**: Soporte para archivos hasta 10MB
- **Emoji Support**: Picker de emojis integrado
- **Message Threading**: Respuestas anidadas
- **Auto-scroll**: Scroll automÃ¡tico a nuevos mensajes

4.1.2 Ticket List Component
```typescript
interface TicketListProps {
    filters: TicketFilters;
    sortBy: TicketSortField;
    groupBy?: TicketGroupField;
    viewMode: 'list' | 'grid' | 'kanban';
    onTicketSelect: (ticket: HelpdeskTicket) => void;
}

interface TicketFilters {
    status: string[];
    priority: string[];
    assignedTo: string[];
    category: string[];
    searchTerm: string;
    dateRange: DateRange;
    slaStatus: 'compliant' | 'at_risk' | 'breached';
}
```

Vista Kanban por estados:
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚    NEW      â”‚    OPEN     â”‚  PENDING    â”‚   RESOLVED  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ [Ticket 1]  â”‚ [Ticket 3]  â”‚ [Ticket 5]  â”‚ [Ticket 7]  â”‚
â”‚ [Ticket 2]  â”‚ [Ticket 4]  â”‚ [Ticket 6]  â”‚ [Ticket 8]  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

4.1.3 Dashboard Widgets

SLA Compliance Widget:
```typescript
interface SLAComplianceWidget {
    data: {
        firstResponse: {
            target: number;    // 95%
            actual: number;    // 92%
            trend: number;     // +2%
        };
        resolution: {
            target: number;    // 90%
            actual: number;    // 88%
            trend: number;     // -1%
        };
    };
    timeframe: 'today' | 'week' | 'month';
}
```

4.2 Layouts Responsive

4.2.1 Desktop Layout (>1024px)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      Top Navigation                         â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚           â”‚                         â”‚                       â”‚
â”‚  Sidebar  â”‚       Main Content      â”‚    Right Panel       â”‚
â”‚  (256px)  â”‚       (flexible)        â”‚      (320px)         â”‚
â”‚           â”‚                         â”‚                       â”‚
â”‚  - Filtersâ”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  - Quick  â”‚  â”‚                     â”‚ â”‚  â”‚                 â”‚ â”‚
â”‚    Actionsâ”‚  â”‚   Ticket List/Chat  â”‚ â”‚  â”‚  Ticket Details â”‚ â”‚
â”‚  - Stats  â”‚  â”‚                     â”‚ â”‚  â”‚                 â”‚ â”‚
â”‚           â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

4.2.2 Mobile Layout (<768px)
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Top Bar + Menu            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                     â”‚
â”‚           Main Content              â”‚
â”‚          (full width)               â”‚
â”‚                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚                                 â”‚â”‚
â”‚  â”‚        Ticket List/Chat         â”‚â”‚
â”‚  â”‚                                 â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚          Bottom Navigation          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

4.3 Design System

4.3.1 Colores del Tema
```typescript
const helpdeskTheme = {
    colors: {
        // Estados de SLA
        sla: {
            compliant: '#10B981',    // Verde
            atRisk: '#F59E0B',       // Amarillo
            breached: '#EF4444',     // Rojo
        },
        
        // Prioridades
        priority: {
            critical: '#DC2626',     // Rojo intenso
            high: '#EA580C',         // Naranja
            medium: '#D97706',       // Amarillo oscuro
            low: '#059669',          // Verde
            veryLow: '#6B7280',      // Gris
        },
        
        // Estados de tickets
        status: {
            new: '#3B82F6',          // Azul
            open: '#8B5CF6',         // PÃºrpura
            pending: '#F59E0B',      // Amarillo
            resolved: '#10B981',     // Verde
            closed: '#6B7280',       // Gris
        },
        
        // Chat
        chat: {
            userMessage: '#3B82F6',  // Azul
            agentMessage: '#6B7280', // Gris
            systemMessage: '#F59E0B', // Amarillo
            internalNote: '#EF4444', // Rojo
        }
    }
};
```

4.3.2 TipografÃ­a
```css
/* JerarquÃ­a tipogrÃ¡fica para HELPDESK */
.helpdesk-title {
    @apply text-2xl font-bold text-gray-900 dark:text-white;
}

.helpdesk-subtitle {
    @apply text-lg font-semibold text-gray-700 dark:text-gray-300;
}

.helpdesk-body {
    @apply text-sm text-gray-600 dark:text-gray-400;
}

.helpdesk-caption {
    @apply text-xs text-gray-500 dark:text-gray-500;
}

.helpdesk-badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

âš™ï¸ 5. LÃ“GICA DE NEGOCIO

5.1 Flujo de Estados de Tickets

```typescript
enum TicketStatus {
    NEW = 'new',
    OPEN = 'open',
    PENDING_CUSTOMER = 'pending_customer',
    PENDING_VENDOR = 'pending_vendor',
    ESCALATED_L2 = 'escalated_l2',
    ESCALATED_L3 = 'escalated_l3',
    ESCALATED_MANAGEMENT = 'escalated_management',
    RESOLVED = 'resolved',
    CLOSED = 'closed',
    ON_HOLD = 'on_hold',
    CLASSIFIED_TO_CASE = 'classified_to_case',
    CANCELLED = 'cancelled'
}

// Transiciones vÃ¡lidas
const VALID_TRANSITIONS = {
    [TicketStatus.NEW]: [TicketStatus.OPEN, TicketStatus.ESCALATED_L2],
    [TicketStatus.OPEN]: [
        TicketStatus.PENDING_CUSTOMER, 
        TicketStatus.ESCALATED_L2, 
        TicketStatus.RESOLVED,
        TicketStatus.CLASSIFIED_TO_CASE,
        TicketStatus.ON_HOLD
    ],
    [TicketStatus.PENDING_CUSTOMER]: [TicketStatus.OPEN, TicketStatus.ESCALATED_L2],
    [TicketStatus.ESCALATED_L2]: [TicketStatus.ESCALATED_L3, TicketStatus.RESOLVED],
    [TicketStatus.RESOLVED]: [TicketStatus.CLOSED, TicketStatus.OPEN],
    // ... resto de transiciones
};
```

5.2 Algoritmo de Auto-asignaciÃ³n

```typescript
interface AutoAssignmentRule {
    priority: number;
    condition: AssignmentCondition;
    action: AssignmentAction;
}

interface AssignmentCondition {
    category?: string[];
    priority?: string[];
    timeOfDay?: TimeRange;
    customerVIP?: boolean;
    keywords?: string[];
}

interface AssignmentAction {
    assignTo?: 'agent' | 'team' | 'specific_user';
    agentId?: string;
    teamId?: string;
    escalationDelay?: number; // minutos
}

class AutoAssignmentEngine {
    async assignTicket(ticket: HelpdeskTicket): Promise<string | null> {
        const rules = await this.getAssignmentRules();
        
        for (const rule of rules.sort((a, b) => a.priority - b.priority)) {
            if (this.evaluateCondition(ticket, rule.condition)) {
                return this.executeAction(ticket, rule.action);
            }
        }
        
        // Fallback: asignar al agente menos ocupado
        return this.assignToLeastBusyAgent();
    }
    
    private evaluateCondition(ticket: HelpdeskTicket, condition: AssignmentCondition): boolean {
        if (condition.category && !condition.category.includes(ticket.category.id)) {
            return false;
        }
        
        if (condition.priority && !condition.priority.includes(ticket.priority.id)) {
            return false;
        }
        
        if (condition.timeOfDay && !this.isWithinTimeRange(condition.timeOfDay)) {
            return false;
        }
        
        if (condition.customerVIP && !ticket.requester.isVIP) {
            return false;
        }
        
        if (condition.keywords && !this.containsKeywords(ticket, condition.keywords)) {
            return false;
        }
        
        return true;
    }
}
```

5.3 Sistema de EscalaciÃ³n

```typescript
interface EscalationRule {
    id: string;
    name: string;
    trigger: EscalationTrigger;
    action: EscalationAction;
    isActive: boolean;
}

interface EscalationTrigger {
    type: 'time_based' | 'sla_breach' | 'manual' | 'priority_based';
    conditions: {
        timeThresholdMinutes?: number;
        slaType?: 'first_response' | 'resolution';
        priorityLevel?: number;
        statusCriteria?: string[];
    };
}

interface EscalationAction {
    escalateTo: 'agent' | 'team' | 'management';
    targetId?: string;
    notifyUsers: string[];
    updatePriority?: boolean;
    addTags?: string[];
    createFollowUpTask?: boolean;
}

class EscalationEngine {
    async processEscalations(): Promise<void> {
        const ticketsToEvaluate = await this.getTicketsForEscalation();
        const rules = await this.getActiveEscalationRules();
        
        for (const ticket of ticketsToEvaluate) {
            for (const rule of rules) {
                if (await this.shouldEscalate(ticket, rule)) {
                    await this.executeEscalation(ticket, rule);
                }
            }
        }
    }
    
    private async shouldEscalate(ticket: HelpdeskTicket, rule: EscalationRule): Promise<boolean> {
        switch (rule.trigger.type) {
            case 'time_based':
                return this.checkTimeBasedEscalation(ticket, rule.trigger.conditions);
            case 'sla_breach':
                return this.checkSLABreachEscalation(ticket, rule.trigger.conditions);
            case 'priority_based':
                return this.checkPriorityBasedEscalation(ticket, rule.trigger.conditions);
            default:
                return false;
        }
    }
}
```

5.4 CÃ¡lculo de SLA

```typescript
interface SLACalculator {
    calculateFirstResponseSLA(ticket: HelpdeskTicket): SLAResult;
    calculateResolutionSLA(ticket: HelpdeskTicket): SLAResult;
    updateSLATracking(ticketId: string, event: SLAEvent): Promise<void>;
}

interface SLAResult {
    targetDate: Date;
    currentStatus: 'compliant' | 'at_risk' | 'breached';
    timeRemaining: number; // minutos
    breachTime?: number; // minutos despuÃ©s del objetivo
}

class SLAService implements SLACalculator {
    calculateFirstResponseSLA(ticket: HelpdeskTicket): SLAResult {
        const baseMinutes = ticket.priority.slaResponseHours * 60;
        const modifier = ticket.category.slaModifierPercentage / 100;
        const adjustedMinutes = baseMinutes * modifier;
        
        const targetDate = new Date(ticket.createdAt.getTime() + adjustedMinutes * 60000);
        const now = new Date();
        const timeRemaining = Math.max(0, targetDate.getTime() - now.getTime()) / 60000;
        
        let currentStatus: 'compliant' | 'at_risk' | 'breached';
        if (ticket.firstResponseAt) {
            currentStatus = ticket.firstResponseAt <= targetDate ? 'compliant' : 'breached';
        } else if (timeRemaining <= adjustedMinutes * 0.2) { // 20% del tiempo restante
            currentStatus = 'at_risk';
        } else {
            currentStatus = 'compliant';
        }
        
        return {
            targetDate,
            currentStatus,
            timeRemaining,
            breachTime: currentStatus === 'breached' ? (now.getTime() - targetDate.getTime()) / 60000 : undefined
        };
    }
    
    async updateSLATracking(ticketId: string, event: SLAEvent): Promise<void> {
        const tracking = await this.getSLATracking(ticketId);
        
        switch (event.type) {
            case 'first_response':
                await this.updateFirstResponseSLA(tracking, event.timestamp);
                break;
            case 'resolution':
                await this.updateResolutionSLA(tracking, event.timestamp);
                break;
            case 'status_change':
                await this.handleStatusChangeSLA(tracking, event);
                break;
        }
    }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ” 6. SEGURIDAD Y PERMISOS

6.1 Row Level Security (RLS)

6.1.1 PolÃ­ticas para helpdesk_tickets
```sql
-- PolÃ­tica para customers: solo ven sus propios tickets
CREATE POLICY "customers_own_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') = 'helpdesk_customer' 
        AND requester_user_id = auth.uid()
    );

-- PolÃ­tica para agentes: ven tickets asignados y de su equipo
CREATE POLICY "agents_assigned_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_agent_l1', 'helpdesk_agent_l2', 'helpdesk_agent_l3')
        AND (
            assigned_agent_id = auth.uid()
            OR assigned_agent_id IN (
                SELECT tm.user_id 
                FROM team_members tm 
                WHERE tm.team_id IN (
                    SELECT tm2.team_id 
                    FROM team_members tm2 
                    WHERE tm2.user_id = auth.uid()
                )
            )
        )
    );

-- PolÃ­tica para supervisores: ven todos los tickets de sus equipos
CREATE POLICY "supervisors_team_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_supervisor', 'helpdesk_team_lead')
        AND assigned_agent_id IN (
            SELECT tm.user_id 
            FROM team_members tm 
            INNER JOIN teams t ON tm.team_id = t.id
            WHERE t.team_lead_id = auth.uid()
        )
    );

-- PolÃ­tica para managers: ven todos los tickets
CREATE POLICY "managers_all_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_manager', 'admin')
    );
```

6.1.2 PolÃ­ticas para helpdesk_chat_messages
```sql
-- Los usuarios pueden ver mensajes de tickets a los que tienen acceso
CREATE POLICY "users_ticket_messages" ON helpdesk_chat_messages
    FOR SELECT USING (
        ticket_id IN (
            SELECT id FROM helpdesk_tickets
            -- Reutiliza las polÃ­ticas de tickets
        )
    );

-- Solo agentes pueden ver mensajes internos
CREATE POLICY "agents_internal_messages" ON helpdesk_chat_messages
    FOR SELECT USING (
        NOT is_internal 
        OR (auth.jwt() ->> 'role') NOT LIKE 'helpdesk_customer%'
    );

-- Los usuarios pueden insertar mensajes en tickets accesibles
CREATE POLICY "users_send_messages" ON helpdesk_chat_messages
    FOR INSERT WITH CHECK (
        ticket_id IN (
            SELECT id FROM helpdesk_tickets
            -- Reutiliza las polÃ­ticas de tickets
        )
        AND sender_user_id = auth.uid()
    );
```

6.2 Funciones de AutorizaciÃ³n

```sql
-- FunciÃ³n para verificar si un usuario puede acceder a un ticket
CREATE OR REPLACE FUNCTION can_access_ticket(ticket_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    user_role TEXT;
    ticket_requester UUID;
    ticket_assigned UUID;
    user_teams UUID[];
    ticket_team UUID;
BEGIN
    -- Obtener rol del usuario
    SELECT role INTO user_role 
    FROM user_profiles 
    WHERE id = user_id;
    
    -- Obtener datos del ticket
    SELECT requester_user_id, assigned_agent_id INTO ticket_requester, ticket_assigned
    FROM helpdesk_tickets 
    WHERE id = ticket_id;
    
    -- Managers y admins pueden ver todo
    IF user_role IN ('helpdesk_manager', 'admin') THEN
        RETURN TRUE;
    END IF;
    
    -- Customers solo ven sus propios tickets
    IF user_role LIKE 'helpdesk_customer%' THEN
        RETURN ticket_requester = user_id;
    END IF;
    
    -- Agentes ven tickets asignados a ellos o a su equipo
    IF user_role LIKE 'helpdesk_agent%' OR user_role LIKE 'helpdesk_supervisor%' THEN
        -- Verificar asignaciÃ³n directa
        IF ticket_assigned = user_id THEN
            RETURN TRUE;
        END IF;
        
        -- Verificar equipo
        SELECT ARRAY_AGG(team_id) INTO user_teams
        FROM team_members 
        WHERE user_id = user_id;
        
        SELECT t.id INTO ticket_team
        FROM teams t
        INNER JOIN team_members tm ON t.id = tm.team_id
        WHERE tm.user_id = ticket_assigned
        LIMIT 1;
        
        RETURN ticket_team = ANY(user_teams);
    END IF;
    
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”„ 7. INTEGRACIÃ“N CON MÃ“DULOS EXISTENTES

7.1 IntegraciÃ³n con MÃ³dulo de Casos

```typescript
interface HelpdeskCaseIntegration {
    // Crear caso desde ticket
    createCaseFromTicket(ticketId: string, classification: CaseClassification): Promise<Case>;
    
    // Vincular ticket existente con caso
    linkTicketToCase(ticketId: string, caseId: string): Promise<void>;
    
    // Sincronizar estados
    syncTicketCaseStatus(ticketId: string, caseId: string): Promise<void>;
    
    // Obtener casos relacionados
    getRelatedCases(ticketId: string): Promise<Case[]>;
}

class HelpdeskCaseService implements HelpdeskCaseIntegration {
    async createCaseFromTicket(ticketId: string, classification: CaseClassification): Promise<Case> {
        const ticket = await this.getTicket(ticketId);
        
        const caseData: CreateCaseData = {
            numeroCaso: await this.generateCaseNumber(),
            descripcion: ticket.description,
            fecha: new Date().toISOString().split('T')[0],
            origenId: await this.getHelpdeskOriginId(),
            aplicacionId: classification.applicationId,
            historialCaso: classification.historialCaso,
            conocimientoModulo: classification.conocimientoModulo,
            manipulacionDatos: classification.manipulacionDatos,
            claridadDescripcion: classification.claridadDescripcion,
            causaFallo: classification.causaFallo,
            userId: ticket.assignedAgentId
        };
        
        // Calcular puntuaciÃ³n y clasificaciÃ³n usando las utilidades existentes
        caseData.puntuacion = calcularPuntuacion(caseData);
        caseData.clasificacion = clasificarCaso(caseData.puntuacion);
        
        const createdCase = await casesService.createCase(caseData);
        
        // Crear vÃ­nculo en tabla de integraciÃ³n
        await this.createCaseLink(ticketId, createdCase.id);
        
        // Actualizar estado del ticket
        await this.updateTicketStatus(ticketId, TicketStatus.CLASSIFIED_TO_CASE);
        
        return createdCase;
    }
    
    async syncTicketCaseStatus(ticketId: string, caseId: string): Promise<void> {
        const caseControl = await caseControlService.getCaseControl(caseId);
        
        if (caseControl) {
            const ticket = await this.getTicket(ticketId);
            
            // Mapear estados de caso a estados de ticket
            const statusMapping = {
                'pending': TicketStatus.OPEN,
                'in_progress': TicketStatus.OPEN,
                'on_hold': TicketStatus.ON_HOLD,
                'completed': TicketStatus.RESOLVED,
                'archived': TicketStatus.CLOSED
            };
            
            const newTicketStatus = statusMapping[caseControl.status.name.toLowerCase()];
            
            if (newTicketStatus && ticket.status !== newTicketStatus) {
                await this.updateTicketStatus(ticketId, newTicketStatus);
                
                // Agregar mensaje del sistema
                await this.addSystemMessage(ticketId, 
                    `Estado actualizado automÃ¡ticamente basado en el caso ${caseControl.case.numeroCaso}: ${caseControl.status.description}`
                );
            }
        }
    }
}
```

7.2 SincronizaciÃ³n de Estados

```typescript
interface StateSyncService {
    // SincronizaciÃ³n bidireccional
    syncTicketToCase(ticketId: string): Promise<void>;
    syncCaseToTicket(caseId: string): Promise<void>;
    
    // Listeners para cambios
    onTicketStatusChange(callback: (ticketId: string, newStatus: string) => void): void;
    onCaseStatusChange(callback: (caseId: string, newStatus: string) => void): void;
}

class StateSynchronizer implements StateSyncService {
    constructor() {
        this.setupRealtimeListeners();
    }
    
    private setupRealtimeListeners(): void {
        // Listener para cambios en tickets
        supabase
            .channel('helpdesk_tickets_changes')
            .on('postgres_changes', 
                { event: 'UPDATE', schema: 'public', table: 'helpdesk_tickets' },
                async (payload) => {
                    const ticketId = payload.new.id;
                    const linkedCases = await this.getLinkedCases(ticketId);
                    
                    for (const caseId of linkedCases) {
                        await this.syncTicketToCase(ticketId);
                    }
                }
            )
            .subscribe();
        
        // Listener para cambios en casos
        supabase
            .channel('case_control_changes')
            .on('postgres_changes',
                { event: 'UPDATE', schema: 'public', table: 'case_control' },
                async (payload) => {
                    const caseId = payload.new.case_id;
                    const linkedTickets = await this.getLinkedTickets(caseId);
                    
                    for (const ticketId of linkedTickets) {
                        await this.syncCaseToTicket(caseId);
                    }
                }
            )
            .subscribe();
    }
}
```

7.3 API de IntegraciÃ³n

```typescript
// Endpoints para integraciÃ³n externa
class HelpdeskAPI {
    // Crear ticket desde API externa
    @Post('/api/helpdesk/tickets')
    async createTicket(@Body() ticketData: CreateTicketAPIRequest): Promise<HelpdeskTicket> {
        // Validar API key
        await this.validateAPIKey(ticketData.apiKey);
        
        // Mapear datos de API a formato interno
        const internalTicketData = this.mapAPIToInternal(ticketData);
        
        // Crear ticket
        return await this.helpdeskService.createTicket(internalTicketData);
    }
    
    // Webhook para notificaciones externas
    @Post('/api/helpdesk/webhooks/:eventType')
    async handleWebhook(@Param('eventType') eventType: string, @Body() data: any): Promise<void> {
        switch (eventType) {
            case 'email_received':
                await this.handleEmailToTicket(data);
                break;
            case 'chat_message':
                await this.handleChatMessage(data);
                break;
            case 'external_update':
                await this.handleExternalUpdate(data);
                break;
        }
    }
    
    // Obtener mÃ©tricas para dashboards externos
    @Get('/api/helpdesk/metrics')
    async getMetrics(@Query() filters: MetricsFilters): Promise<HelpdeskMetrics> {
        return await this.metricsService.getMetrics(filters);
    }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“Š 8. MÃ‰TRICAS Y REPORTES

8.1 KPIs Principales

```typescript
interface HelpdeskKPIs {
    // MÃ©tricas de SLA
    slaMetrics: {
        firstResponseCompliance: number;      // Porcentaje de cumplimiento primera respuesta
        resolutionCompliance: number;         // Porcentaje de cumplimiento resoluciÃ³n
        averageResponseTime: number;          // Tiempo promedio primera respuesta (minutos)
        averageResolutionTime: number;        // Tiempo promedio resoluciÃ³n (horas)
    };
    
    // MÃ©tricas de volumen
    volumeMetrics: {
        totalTickets: number;                 // Total de tickets en perÃ­odo
        newTickets: number;                   // Tickets nuevos
        resolvedTickets: number;              // Tickets resueltos
        escalatedTickets: number;             // Tickets escalados
        reopenedTickets: number;              // Tickets reabiertos
    };
    
    // MÃ©tricas de calidad
    qualityMetrics: {
        customerSatisfactionScore: number;    // CSAT promedio (1-5)
        firstCallResolutionRate: number;     // Porcentaje FCR
        escalationRate: number;               // Porcentaje de escalaciÃ³n
        agentUtilizationRate: number;         // Porcentaje utilizaciÃ³n agentes
    };
    
    // MÃ©tricas de productividad
    productivityMetrics: {
        ticketsPerAgent: number;              // Promedio tickets por agente
        resolutionsByCategory: CategoryStats[]; // Resoluciones por categorÃ­a
        peakHoursAnalysis: HourlyStats[];     // AnÃ¡lisis horas pico
        channelEffectiveness: ChannelStats[]; // Efectividad por canal
    };
}
```

8.2 Consultas de MÃ©tricas

```sql
-- Vista materializada para mÃ©tricas de SLA
CREATE MATERIALIZED VIEW helpdesk_sla_metrics AS
SELECT 
    DATE_TRUNC('day', ht.created_at) as metric_date,
    hp.name as priority_name,
    hc.name as category_name,
    COUNT(*) as total_tickets,
    
    -- MÃ©tricas de primera respuesta
    COUNT(CASE WHEN ht.first_response_at IS NOT NULL 
               AND ht.first_response_at <= sla.first_response_due 
               THEN 1 END) as first_response_compliant,
    AVG(EXTRACT(EPOCH FROM (ht.first_response_at - ht.created_at))/60) as avg_first_response_minutes,
    
    -- MÃ©tricas de resoluciÃ³n
    COUNT(CASE WHEN ht.resolution_date IS NOT NULL 
               AND ht.resolution_date <= sla.resolution_due 
               THEN 1 END) as resolution_compliant,
    AVG(EXTRACT(EPOCH FROM (ht.resolution_date - ht.created_at))/3600) as avg_resolution_hours,
    
    -- SatisfacciÃ³n del cliente
    AVG(ht.satisfaction_rating) as avg_satisfaction
FROM helpdesk_tickets ht
LEFT JOIN helpdesk_priorities hp ON ht.priority_id = hp.id
LEFT JOIN helpdesk_categories hc ON ht.category_id = hc.id
LEFT JOIN helpdesk_sla_tracking sla ON ht.id = sla.ticket_id
WHERE ht.created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE_TRUNC('day', ht.created_at), hp.name, hc.name;

-- FunciÃ³n para obtener mÃ©tricas de agente
CREATE OR REPLACE FUNCTION get_agent_metrics(
    p_agent_id UUID,
    p_start_date DATE DEFAULT CURRENT_DATE - INTERVAL '7 days',
    p_end_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE(
    total_assigned INTEGER,
    total_resolved INTEGER,
    avg_response_time_minutes NUMERIC,
    avg_resolution_time_hours NUMERIC,
    escalation_rate NUMERIC,
    satisfaction_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_assigned,
        COUNT(CASE WHEN ht.resolution_date IS NOT NULL THEN 1 END)::INTEGER as total_resolved,
        AVG(EXTRACT(EPOCH FROM (ht.first_response_at - ht.created_at))/60) as avg_response_time_minutes,
        AVG(EXTRACT(EPOCH FROM (ht.resolution_date - ht.created_at))/3600) as avg_resolution_time_hours,
        (COUNT(CASE WHEN he.id IS NOT NULL THEN 1 END)::NUMERIC / COUNT(*)::NUMERIC * 100) as escalation_rate,
        AVG(ht.satisfaction_rating) as satisfaction_score
    FROM helpdesk_tickets ht
    LEFT JOIN helpdesk_escalations he ON ht.id = he.ticket_id
    WHERE ht.assigned_agent_id = p_agent_id
    AND ht.created_at::DATE BETWEEN p_start_date AND p_end_date;
END;
$$ LANGUAGE plpgsql;
```

8.3 Dashboard de MÃ©tricas

```typescript
interface HelpdeskDashboard {
    // Widget principal de SLA
    slaOverviewWidget: {
        currentPeriod: 'today' | 'week' | 'month';
        targets: {
            firstResponseTarget: number;    // 95%
            resolutionTarget: number;       // 90%
        };
        actual: {
            firstResponseActual: number;
            resolutionActual: number;
        };
        trends: {
            firstResponseTrend: number;     // +2%
            resolutionTrend: number;        // -1%
        };
    };
    
    // Widget de tickets crÃ­ticos
    criticalTicketsWidget: {
        slaBreached: HelpdeskTicket[];
        aboutToBreach: HelpdeskTicket[];
        unassigned: HelpdeskTicket[];
        highPriority: HelpdeskTicket[];
    };
    
    // Widget de distribuciÃ³n de carga
    workloadWidget: {
        agentDistribution: {
            agentId: string;
            agentName: string;
            activeTickets: number;
            todayResolved: number;
            avgResponseTime: number;
            status: 'available' | 'busy' | 'away';
        }[];
        teamStatistics: {
            teamName: string;
            totalCapacity: number;
            currentLoad: number;
            queueLength: number;
        }[];
    };
    
    // Widget de satisfacciÃ³n
    satisfactionWidget: {
        currentScore: number;
        trend: number;
        distribution: Record<number, number>; // Rating -> Count
        recentFeedback: {
            ticketNumber: string;
            rating: number;
            comment: string;
            agentName: string;
            date: string;
        }[];
    };
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”” 9. SISTEMA DE NOTIFICACIONES

9.1 Arquitectura del Sistema de Notificaciones

El sistema de notificaciones es un componente fundamental que mantiene a todos los usuarios informados sobre eventos crÃ­ticos en tiempo real, garantizando respuestas rÃ¡pidas y cumplimiento de SLA.

**9.1.1 Diagrama de Flujo de Notificaciones**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SISTEMA DE NOTIFICACIONES                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   GENERADORES   â”‚      PROCESAMIENTO        â”‚    ENTREGA        â”‚
â”‚                 â”‚                           â”‚                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚ SLA Events  â”‚â”€â”¼â–ºâ”‚  Notification Engine    â”‚â”€â”¼â–ºâ”‚ Web Browser â”‚ â”‚
â”‚ â”‚ Ticket Ops  â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚ Push Notif. â”‚ â”‚
â”‚ â”‚ Chat Msgs   â”‚â”€â”¼â–ºâ”‚    Priority Queue       â”‚â”€â”¼â–ºâ”‚ Email       â”‚ â”‚
â”‚ â”‚ Escalations â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚ SMS         â”‚ â”‚
â”‚ â”‚ Case Sync   â”‚â”€â”¼â–ºâ”‚   Template Engine       â”‚â”€â”¼â–ºâ”‚ In-App      â”‚ â”‚
â”‚ â”‚ System      â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚ Sound       â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   PERSISTENCE     â”‚
                    â”‚                   â”‚
                    â”‚ â€¢ Notification    â”‚
                    â”‚   History         â”‚
                    â”‚ â€¢ User Settings   â”‚
                    â”‚ â€¢ Delivery Status â”‚
                    â”‚ â€¢ Analytics       â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**9.1.2 Tipos de Notificaciones**

```typescript
enum NotificationType {
  // Notificaciones de Tickets
  TICKET_CREATED = 'ticket_created',
  TICKET_ASSIGNED = 'ticket_assigned',
  TICKET_STATUS_CHANGED = 'ticket_status_changed',
  TICKET_ESCALATED = 'ticket_escalated',
  TICKET_REOPENED = 'ticket_reopened',
  TICKET_RESOLVED = 'ticket_resolved',
  TICKET_CLOSED = 'ticket_closed',
  
  // Notificaciones de SLA
  SLA_WARNING_15MIN = 'sla_warning_15min',
  SLA_WARNING_5MIN = 'sla_warning_5min',
  SLA_BREACH = 'sla_breach',
  SLA_CRITICAL = 'sla_critical',
  
  // Notificaciones de Chat
  NEW_MESSAGE = 'new_message',
  INTERNAL_MESSAGE = 'internal_message',
  CHAT_TYPING = 'chat_typing',
  
  // Notificaciones de EscalaciÃ³n
  ESCALATION_RECEIVED = 'escalation_received',
  ESCALATION_TIMEOUT = 'escalation_timeout',
  ESCALATION_RESOLVED = 'escalation_resolved',
  
  // Notificaciones de IntegraciÃ³n
  TICKET_CONVERTED_TO_CASE = 'ticket_converted_to_case',
  CASE_STATUS_SYNCED = 'case_status_synced',
  CASE_ASSIGNED_FROM_TICKET = 'case_assigned_from_ticket',
  
  // Notificaciones del Sistema
  SYSTEM_MAINTENANCE = 'system_maintenance',
  PERFORMANCE_ALERT = 'performance_alert',
  SECURITY_ALERT = 'security_alert',
  
  // Notificaciones de SatisfacciÃ³n
  SATISFACTION_SURVEY = 'satisfaction_survey',
  FEEDBACK_RECEIVED = 'feedback_received'
}

enum NotificationPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

enum NotificationCategory {
  TICKET = 'ticket',
  SLA = 'sla',
  CHAT = 'chat',
  ESCALATION = 'escalation',
  INTEGRATION = 'integration',
  SYSTEM = 'system',
  SATISFACTION = 'satisfaction'
}
```

9.2 Modelo de Datos de Notificaciones

**9.2.1 Esquema de Base de Datos**

```sql
-- Tabla principal de notificaciones
CREATE TABLE helpdesk_notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    priority notification_priority DEFAULT 'medium',
    category notification_category DEFAULT 'system',
    
    -- InformaciÃ³n de contexto
    related_entity_id UUID,
    related_entity_type VARCHAR(50),
    metadata JSONB DEFAULT '{}',
    
    -- Estado y seguimiento
    is_read BOOLEAN DEFAULT FALSE,
    requires_action BOOLEAN DEFAULT FALSE,
    action_url TEXT,
    action_label VARCHAR(100),
    
    -- ConfiguraciÃ³n de entrega
    delivery_channels TEXT[] DEFAULT ARRAY['in_app'],
    delivery_status JSONB DEFAULT '{}',
    
    -- Control de tiempo
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    read_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Ãndices para optimizaciÃ³n
    INDEX idx_notifications_user_unread (user_id, is_read, created_at DESC),
    INDEX idx_notifications_type_category (type, category),
    INDEX idx_notifications_priority_created (priority, created_at DESC),
    INDEX idx_notifications_related_entity (related_entity_type, related_entity_id),
    INDEX idx_notifications_expires (expires_at) WHERE expires_at IS NOT NULL
);

-- Tabla de configuraciÃ³n de notificaciones por usuario
CREATE TABLE helpdesk_notification_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    notification_type VARCHAR(50) NOT NULL,
    
    -- Canales habilitados
    enabled_channels TEXT[] DEFAULT ARRAY['in_app'],
    is_enabled BOOLEAN DEFAULT TRUE,
    
    -- Configuraciones especÃ­ficas
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    quiet_days INTEGER[] DEFAULT '{}', -- 0=Domingo, 1=Lunes, etc.
    
    -- AgrupaciÃ³n y frecuencia
    batch_enabled BOOLEAN DEFAULT FALSE,
    batch_frequency_minutes INTEGER DEFAULT 15,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Constraint Ãºnico por usuario y tipo
    UNIQUE(user_id, notification_type)
);

-- Tabla de plantillas de notificaciones
CREATE TABLE helpdesk_notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    type VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    
    -- Plantillas por canal
    in_app_title VARCHAR(255),
    in_app_message TEXT,
    email_subject VARCHAR(255),
    email_html TEXT,
    email_text TEXT,
    sms_message VARCHAR(160),
    push_title VARCHAR(100),
    push_message VARCHAR(255),
    
    -- Variables disponibles
    available_variables JSONB DEFAULT '[]',
    
    -- ConfiguraciÃ³n
    is_active BOOLEAN DEFAULT TRUE,
    priority notification_priority DEFAULT 'medium',
    category notification_category DEFAULT 'system',
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tipos enumerados
CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'critical');
CREATE TYPE notification_category AS ENUM ('ticket', 'sla', 'chat', 'escalation', 'integration', 'system', 'satisfaction');

-- PolÃ­ticas RLS
ALTER TABLE helpdesk_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE helpdesk_notification_settings ENABLE ROW LEVEL SECURITY;

-- Los usuarios solo ven sus propias notificaciones
CREATE POLICY "users_own_notifications" ON helpdesk_notifications
    FOR ALL USING (user_id = auth.uid());

CREATE POLICY "users_own_notification_settings" ON helpdesk_notification_settings
    FOR ALL USING (user_id = auth.uid());

-- Solo administradores pueden gestionar plantillas
CREATE POLICY "admins_manage_templates" ON helpdesk_notification_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'helpdesk_manager')
        )
    );
```

**9.2.2 Interfaces TypeScript**

```typescript
interface HelpdeskNotification {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  message: string;
  priority: NotificationPriority;
  category: NotificationCategory;
  
  // Contexto
  relatedEntityId?: string;
  relatedEntityType?: string;
  metadata: Record<string, any>;
  
  // Estado
  isRead: boolean;
  requiresAction: boolean;
  actionUrl?: string;
  actionLabel?: string;
  
  // Entrega
  deliveryChannels: NotificationChannel[];
  deliveryStatus: Record<NotificationChannel, DeliveryStatus>;
  
  // Tiempo
  expiresAt?: Date;
  createdAt: Date;
  readAt?: Date;
  updatedAt: Date;
}

interface NotificationSettings {
  id: string;
  userId: string;
  notificationType: NotificationType;
  enabledChannels: NotificationChannel[];
  isEnabled: boolean;
  quietHoursStart?: string;
  quietHoursEnd?: string;
  quietDays: number[];
  batchEnabled: boolean;
  batchFrequencyMinutes: number;
}

interface NotificationTemplate {
  id: string;
  type: NotificationType;
  name: string;
  inAppTitle?: string;
  inAppMessage?: string;
  emailSubject?: string;
  emailHtml?: string;
  emailText?: string;
  smsMessage?: string;
  pushTitle?: string;
  pushMessage?: string;
  availableVariables: string[];
  isActive: boolean;
  priority: NotificationPriority;
  category: NotificationCategory;
}

enum NotificationChannel {
  IN_APP = 'in_app',
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  SOUND = 'sound'
}

enum DeliveryStatus {
  PENDING = 'pending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  FAILED = 'failed',
  BOUNCED = 'bounced'
}
```

9.3 Motor de Notificaciones

**9.3.1 Servicio Principal**

```typescript
class NotificationEngine {
  private templateEngine: TemplateEngine;
  private deliveryService: DeliveryService;
  private settingsService: NotificationSettingsService;
  
  constructor() {
    this.templateEngine = new TemplateEngine();
    this.deliveryService = new DeliveryService();
    this.settingsService = new NotificationSettingsService();
  }
  
  async createNotification(data: CreateNotificationData): Promise<HelpdeskNotification> {
    // Validar y procesar datos
    const validatedData = this.validateNotificationData(data);
    
    // Obtener configuraciones del usuario
    const userSettings = await this.settingsService.getUserSettings(
      data.userId, 
      data.type
    );
    
    // Verificar si las notificaciones estÃ¡n habilitadas
    if (!userSettings.isEnabled) {
      throw new Error('Notifications disabled for this type');
    }
    
    // Verificar horas silenciosas
    if (this.isInQuietHours(userSettings)) {
      // Programar para despuÃ©s de las horas silenciosas
      await this.scheduleNotification(validatedData, userSettings);
      return;
    }
    
    // Renderizar contenido usando plantillas
    const renderedContent = await this.templateEngine.render(
      data.type,
      data.templateVariables || {}
    );
    
    // Crear notificaciÃ³n en base de datos
    const notification = await this.saveNotification({
      ...validatedData,
      ...renderedContent,
      deliveryChannels: userSettings.enabledChannels
    });
    
    // Entregar notificaciÃ³n
    await this.deliverNotification(notification, userSettings);
    
    return notification;
  }
  
  private async deliverNotification(
    notification: HelpdeskNotification,
    settings: NotificationSettings
  ): Promise<void> {
    const deliveryPromises = settings.enabledChannels.map(channel => 
      this.deliveryService.deliver(notification, channel)
    );
    
    // Ejecutar entregas en paralelo
    const results = await Promise.allSettled(deliveryPromises);
    
    // Actualizar estado de entrega
    const deliveryStatus: Record<NotificationChannel, DeliveryStatus> = {};
    results.forEach((result, index) => {
      const channel = settings.enabledChannels[index];
      deliveryStatus[channel] = result.status === 'fulfilled' 
        ? DeliveryStatus.SENT 
        : DeliveryStatus.FAILED;
    });
    
    // Actualizar en base de datos
    await this.updateDeliveryStatus(notification.id, deliveryStatus);
  }
  
  private isInQuietHours(settings: NotificationSettings): boolean {
    if (!settings.quietHoursStart || !settings.quietHoursEnd) return false;
    
    const now = new Date();
    const currentDay = now.getDay();
    const currentTime = now.toTimeString().slice(0, 5);
    
    // Verificar si hoy es un dÃ­a silencioso
    if (settings.quietDays.includes(currentDay)) {
      return true;
    }
    
    // Verificar horario silencioso
    const startTime = settings.quietHoursStart;
    const endTime = settings.quietHoursEnd;
    
    if (startTime <= endTime) {
      // Mismo dÃ­a (ej: 22:00 - 08:00)
      return currentTime >= startTime && currentTime <= endTime;
    } else {
      // Cruza medianoche (ej: 22:00 - 08:00)
      return currentTime >= startTime || currentTime <= endTime;
    }
  }
}

interface CreateNotificationData {
  userId: string;
  type: NotificationType;
  relatedEntityId?: string;
  relatedEntityType?: string;
  templateVariables?: Record<string, any>;
  priority?: NotificationPriority;
  requiresAction?: boolean;
  actionUrl?: string;
  actionLabel?: string;
  expiresAt?: Date;
}
```

**9.3.2 Motor de Plantillas**

```typescript
class TemplateEngine {
  private templates: Map<NotificationType, NotificationTemplate> = new Map();
  
  constructor() {
    this.loadTemplates();
  }
  
  async render(type: NotificationType, variables: Record<string, any>): Promise<RenderedNotification> {
    const template = this.templates.get(type);
    if (!template || !template.isActive) {
      throw new Error(`Template not found or inactive: ${type}`);
    }
    
    return {
      title: this.renderTemplate(template.inAppTitle || '', variables),
      message: this.renderTemplate(template.inAppMessage || '', variables),
      emailSubject: this.renderTemplate(template.emailSubject || '', variables),
      emailHtml: this.renderTemplate(template.emailHtml || '', variables),
      emailText: this.renderTemplate(template.emailText || '', variables),
      smsMessage: this.renderTemplate(template.smsMessage || '', variables),
      pushTitle: this.renderTemplate(template.pushTitle || '', variables),
      pushMessage: this.renderTemplate(template.pushMessage || '', variables),
      priority: template.priority,
      category: template.category
    };
  }
  
  private renderTemplate(template: string, variables: Record<string, any>): string {
    if (!template) return '';
    
    // Reemplazar variables usando sintaxis {{variable}}
    return template.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return variables[varName] || match;
    });
  }
  
  private async loadTemplates(): Promise<void> {
    const { data: templates } = await supabase
      .from('helpdesk_notification_templates')
      .select('*')
      .eq('is_active', true);
    
    templates?.forEach(template => {
      this.templates.set(template.type as NotificationType, template);
    });
  }
}

interface RenderedNotification {
  title: string;
  message: string;
  emailSubject: string;
  emailHtml: string;
  emailText: string;
  smsMessage: string;
  pushTitle: string;
  pushMessage: string;
  priority: NotificationPriority;
  category: NotificationCategory;
}
```

**9.3.3 Servicio de Entrega**

```typescript
class DeliveryService {
  async deliver(
    notification: HelpdeskNotification, 
    channel: NotificationChannel
  ): Promise<DeliveryResult> {
    switch (channel) {
      case NotificationChannel.IN_APP:
        return await this.deliverInApp(notification);
      
      case NotificationChannel.EMAIL:
        return await this.deliverEmail(notification);
      
      case NotificationChannel.SMS:
        return await this.deliverSMS(notification);
      
      case NotificationChannel.PUSH:
        return await this.deliverPush(notification);
      
      case NotificationChannel.SOUND:
        return await this.deliverSound(notification);
      
      default:
        throw new Error(`Unsupported delivery channel: ${channel}`);
    }
  }
  
  private async deliverInApp(notification: HelpdeskNotification): Promise<DeliveryResult> {
    // La notificaciÃ³n ya estÃ¡ en la base de datos
    // Enviar vÃ­a Supabase Realtime
    await supabase
      .channel('user_notifications')
      .send({
        type: 'broadcast',
        event: 'new_notification',
        payload: {
          userId: notification.userId,
          notification: notification
        }
      });
    
    return { status: DeliveryStatus.SENT, channel: NotificationChannel.IN_APP };
  }
  
  private async deliverEmail(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener email del usuario
      const { data: user } = await supabase
        .from('user_profiles')
        .select('email, full_name')
        .eq('id', notification.userId)
        .single();
      
      if (!user?.email) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.EMAIL,
          error: 'User email not found'
        };
      }
      
      // Configurar y enviar email
      const emailData = {
        to: user.email,
        subject: notification.title,
        html: this.buildEmailHTML(notification, user),
        text: notification.message
      };
      
      // AquÃ­ integrarÃ­as con tu proveedor de email (SendGrid, Resend, etc.)
      await this.sendEmail(emailData);
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.EMAIL };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.EMAIL,
        error: error.message 
      };
    }
  }
  
  private async deliverSMS(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener nÃºmero de telÃ©fono del usuario
      const { data: user } = await supabase
        .from('user_profiles')
        .select('phone_number')
        .eq('id', notification.userId)
        .single();
      
      if (!user?.phone_number) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.SMS,
          error: 'User phone number not found'
        };
      }
      
      // Enviar SMS (integraciÃ³n con Twilio, AWS SNS, etc.)
      await this.sendSMS({
        to: user.phone_number,
        message: `${notification.title}: ${notification.message}`
      });
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.SMS };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.SMS,
        error: error.message 
      };
    }
  }
  
  private async deliverPush(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener tokens de push del usuario
      const { data: tokens } = await supabase
        .from('user_push_tokens')
        .select('token, platform')
        .eq('user_id', notification.userId)
        .eq('is_active', true);
      
      if (!tokens || tokens.length === 0) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.PUSH,
          error: 'No active push tokens found'
        };
      }
      
      // Enviar push notifications
      const pushPromises = tokens.map(tokenData => 
        this.sendPushNotification({
          token: tokenData.token,
          title: notification.title,
          body: notification.message,
          data: {
            notificationId: notification.id,
            type: notification.type,
            actionUrl: notification.actionUrl
          }
        })
      );
      
      await Promise.all(pushPromises);
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.PUSH };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.PUSH,
        error: error.message 
      };
    }
  }
  
  private async deliverSound(notification: HelpdeskNotification): Promise<DeliveryResult> {
    // Para notificaciones de sonido, enviamos seÃ±al via Realtime
    await supabase
      .channel('user_notifications')
      .send({
        type: 'broadcast',
        event: 'play_notification_sound',
        payload: {
          userId: notification.userId,
          soundType: this.getSoundType(notification.priority),
          repeat: notification.priority === NotificationPriority.CRITICAL ? 3 : 1
        }
      });
    
    return { status: DeliveryStatus.SENT, channel: NotificationChannel.SOUND };
  }
  
  private getSoundType(priority: NotificationPriority): string {
    switch (priority) {
      case NotificationPriority.CRITICAL:
        return 'critical_alert';
      case NotificationPriority.HIGH:
        return 'high_priority';
      case NotificationPriority.MEDIUM:
        return 'standard';
      default:
        return 'low_priority';
    }
  }
}

interface DeliveryResult {
  status: DeliveryStatus;
  channel: NotificationChannel;
  error?: string;
  messageId?: string;
}
```

9.4 Generadores de Notificaciones

**9.4.1 Eventos de Tickets**

```typescript
class TicketNotificationGenerator {
  private notificationEngine: NotificationEngine;
  
  constructor(notificationEngine: NotificationEngine) {
    this.notificationEngine = notificationEngine;
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // Escuchar cambios en tickets
    supabase
      .channel('ticket_notifications')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, this.handleTicketCreated.bind(this))
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, this.handleTicketUpdated.bind(this))
      .subscribe();
  }
  
  private async handleTicketCreated(payload: any): Promise<void> {
    const ticket = payload.new;
    
    // Notificar al agente asignado (si hay uno)
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: NotificationType.TICKET_ASSIGNED,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: this.mapTicketPriorityToNotificationPriority(ticket.priority_id),
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Ver Ticket',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          customerName: ticket.requester_name,
          priority: ticket.priority_name
        }
      });
    }
    
    // Notificar al supervisor del equipo
    const supervisor = await this.getTeamSupervisor(ticket.assigned_team_id);
    if (supervisor) {
      await this.notificationEngine.createNotification({
        userId: supervisor.id,
        type: NotificationType.TICKET_CREATED,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.MEDIUM,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          customerName: ticket.requester_name,
          assignedAgent: ticket.assigned_agent_name
        }
      });
    }
  }
  
  private async handleTicketUpdated(payload: any): Promise<void> {
    const oldTicket = payload.old;
    const newTicket = payload.new;
    
    // Verificar cambio de asignaciÃ³n
    if (oldTicket.assigned_agent_id !== newTicket.assigned_agent_id) {
      await this.handleTicketReassigned(oldTicket, newTicket);
    }
    
    // Verificar cambio de estado
    if (oldTicket.status_id !== newTicket.status_id) {
      await this.handleTicketStatusChanged(oldTicket, newTicket);
    }
    
    // Verificar escalaciÃ³n
    if (!oldTicket.escalated_to_user_id && newTicket.escalated_to_user_id) {
      await this.handleTicketEscalated(newTicket);
    }
  }
  
  private async handleTicketReassigned(oldTicket: any, newTicket: any): Promise<void> {
    // Notificar al nuevo agente
    if (newTicket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: newTicket.assigned_agent_id,
        type: NotificationType.TICKET_ASSIGNED,
        relatedEntityId: newTicket.id,
        relatedEntityType: 'ticket',
        priority: this.mapTicketPriorityToNotificationPriority(newTicket.priority_id),
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${newTicket.id}`,
        actionLabel: 'Ver Ticket',
        templateVariables: {
          ticketNumber: newTicket.ticket_number,
          ticketSubject: newTicket.subject,
          customerName: newTicket.requester_name,
          previousAgent: oldTicket.assigned_agent_name
        }
      });
    }
    
    // Notificar al agente anterior (si corresponde)
    if (oldTicket.assigned_agent_id && oldTicket.assigned_agent_id !== newTicket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: oldTicket.assigned_agent_id,
        type: NotificationType.TICKET_STATUS_CHANGED,
        relatedEntityId: newTicket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.MEDIUM,
        templateVariables: {
          ticketNumber: newTicket.ticket_number,
          action: 'reasignado',
          newAgent: newTicket.assigned_agent_name
        }
      });
    }
  }
  
  private async handleTicketStatusChanged(oldTicket: any, newTicket: any): Promise<void> {
    const statusMappings = {
      'resolved': { type: NotificationType.TICKET_RESOLVED, priority: NotificationPriority.MEDIUM },
      'closed': { type: NotificationType.TICKET_CLOSED, priority: NotificationPriority.LOW },
      'reopened': { type: NotificationType.TICKET_REOPENED, priority: NotificationPriority.HIGH }
    };
    
    const statusConfig = statusMappings[newTicket.status_name.toLowerCase()];
    if (!statusConfig) return;
    
    // Notificar al cliente
    await this.notificationEngine.createNotification({
      userId: newTicket.requester_user_id,
      type: statusConfig.type,
      relatedEntityId: newTicket.id,
      relatedEntityType: 'ticket',
      priority: statusConfig.priority,
      actionUrl: `/helpdesk/tickets/${newTicket.id}`,
      templateVariables: {
        ticketNumber: newTicket.ticket_number,
        ticketSubject: newTicket.subject,
        newStatus: newTicket.status_name,
        agentName: newTicket.assigned_agent_name
      }
    });
    
    // Si se resolviÃ³, enviar encuesta de satisfacciÃ³n despuÃ©s de un delay
    if (newTicket.status_name.toLowerCase() === 'resolved') {
      await this.scheduleCustomerSatisfactionSurvey(newTicket);
    }
  }
  
  private async handleTicketEscalated(ticket: any): Promise<void> {
    // Notificar al usuario escalado
    await this.notificationEngine.createNotification({
      userId: ticket.escalated_to_user_id,
      type: NotificationType.ESCALATION_RECEIVED,
      relatedEntityId: ticket.id,
      relatedEntityType: 'ticket',
      priority: NotificationPriority.HIGH,
      requiresAction: true,
      actionUrl: `/helpdesk/tickets/${ticket.id}`,
      actionLabel: 'Revisar EscalaciÃ³n',
      templateVariables: {
        ticketNumber: ticket.ticket_number,
        ticketSubject: ticket.subject,
        escalatedFrom: ticket.assigned_agent_name,
        escalationReason: ticket.escalation_reason
      }
    });
  }
  
  private mapTicketPriorityToNotificationPriority(ticketPriorityId: string): NotificationPriority {
    // Mapear prioridades de ticket a prioridades de notificaciÃ³n
    const priorityMap = {
      '1': NotificationPriority.CRITICAL,
      '2': NotificationPriority.HIGH,
      '3': NotificationPriority.MEDIUM,
      '4': NotificationPriority.LOW,
      '5': NotificationPriority.LOW
    };
    
    return priorityMap[ticketPriorityId] || NotificationPriority.MEDIUM;
  }
}
```

**9.4.2 Eventos de SLA**

```typescript
class SLANotificationGenerator {
  private notificationEngine: NotificationEngine;
  private slaService: SLAService;
  
  constructor(notificationEngine: NotificationEngine, slaService: SLAService) {
    this.notificationEngine = notificationEngine;
    this.slaService = slaService;
    this.startSLAMonitoring();
  }
  
  private startSLAMonitoring(): void {
    // Ejecutar cada minuto para verificar SLA
    setInterval(async () => {
      await this.checkSLABreaches();
    }, 60000); // 1 minuto
  }
  
  private async checkSLABreaches(): Promise<void> {
    // Obtener tickets activos con SLA
    const { data: activeTickets } = await supabase
      .from('helpdesk_tickets')
      .select(`
        id, ticket_number, subject, priority_id, assigned_agent_id,
        requester_user_id, created_at, first_response_at,
        helpdesk_sla_tracking (
          first_response_due, resolution_due, 
          first_response_notified, resolution_notified
        )
      `)
      .in('status_name', ['new', 'open', 'pending', 'in_progress'])
      .not('helpdesk_sla_tracking', 'is', null);
    
    if (!activeTickets) return;
    
    const now = new Date();
    
    for (const ticket of activeTickets) {
      const slaTracking = ticket.helpdesk_sla_tracking[0];
      if (!slaTracking) continue;
      
      // Verificar SLA de primera respuesta
      if (!ticket.first_response_at && !slaTracking.first_response_notified) {
        await this.checkFirstResponseSLA(ticket, slaTracking, now);
      }
      
      // Verificar SLA de resoluciÃ³n
      if (!slaTracking.resolution_notified) {
        await this.checkResolutionSLA(ticket, slaTracking, now);
      }
    }
  }
  
  private async checkFirstResponseSLA(ticket: any, slaTracking: any, now: Date): Promise<void> {
    const dueDate = new Date(slaTracking.first_response_due);
    const timeUntilBreach = dueDate.getTime() - now.getTime();
    const minutesUntilBreach = Math.floor(timeUntilBreach / 60000);
    
    // Alertas a 15 minutos, 5 minutos y cuando se incumple
    if (minutesUntilBreach <= 15 && minutesUntilBreach > 5) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_15MIN, minutesUntilBreach);
      await this.markSLANotified(ticket.id, 'first_response_15min');
    } else if (minutesUntilBreach <= 5 && minutesUntilBreach > 0) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_5MIN, minutesUntilBreach);
      await this.markSLANotified(ticket.id, 'first_response_5min');
    } else if (minutesUntilBreach <= 0) {
      await this.sendSLABreach(ticket, 'first_response');
      await this.markSLANotified(ticket.id, 'first_response_breach');
    }
  }
  
  private async checkResolutionSLA(ticket: any, slaTracking: any, now: Date): Promise<void> {
    const dueDate = new Date(slaTracking.resolution_due);
    const timeUntilBreach = dueDate.getTime() - now.getTime();
    const minutesUntilBreach = Math.floor(timeUntilBreach / 60000);
    
    if (minutesUntilBreach <= 30 && minutesUntilBreach > 15) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_15MIN, minutesUntilBreach);
    } else if (minutesUntilBreach <= 15 && minutesUntilBreach > 0) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_5MIN, minutesUntilBreach);
    } else if (minutesUntilBreach <= 0) {
      await this.sendSLABreach(ticket, 'resolution');
    }
  }
  
  private async sendSLAWarning(ticket: any, type: NotificationType, minutesRemaining: number): Promise<void> {
    const priority = minutesRemaining <= 5 ? NotificationPriority.HIGH : NotificationPriority.MEDIUM;
    
    // Notificar al agente asignado
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: type,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: priority,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Atender Urgente',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          minutesRemaining: minutesRemaining.toString(),
          timeUnit: minutesRemaining === 1 ? 'minuto' : 'minutos'
        }
      });
    }
    
    // Notificar al supervisor si quedan menos de 5 minutos
    if (minutesRemaining <= 5) {
      const supervisor = await this.getTicketSupervisor(ticket.id);
      if (supervisor) {
        await this.notificationEngine.createNotification({
          userId: supervisor.id,
          type: type,
          relatedEntityId: ticket.id,
          relatedEntityType: 'ticket',
          priority: NotificationPriority.HIGH,
          templateVariables: {
            ticketNumber: ticket.ticket_number,
            agentName: ticket.assigned_agent_name,
            minutesRemaining: minutesRemaining.toString()
          }
        });
      }
    }
  }
  
  private async sendSLABreach(ticket: any, slaType: string): Promise<void> {
    // Notificar al agente asignado
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: NotificationType.SLA_BREACH,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Atender Inmediatamente',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'ResoluciÃ³n'
        }
      });
    }
    
    // Notificar al supervisor
    const supervisor = await this.getTicketSupervisor(ticket.id);
    if (supervisor) {
      await this.notificationEngine.createNotification({
        userId: supervisor.id,
        type: NotificationType.SLA_BREACH,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          agentName: ticket.assigned_agent_name,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'ResoluciÃ³n'
        }
      });
    }
    
    // Notificar al manager para incumplimientos crÃ­ticos
    const manager = await this.getHelpdeskManager();
    if (manager) {
      await this.notificationEngine.createNotification({
        userId: manager.id,
        type: NotificationType.SLA_CRITICAL,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'ResoluciÃ³n',
          agentName: ticket.assigned_agent_name
export function NotificationSettings() {
  const { user } = useAuth();
  const [settings, setSettings] = useState<NotificationSettings[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  
  // Tipos de notificaciÃ³n disponibles
  const notificationTypes = [
    { 
      type: NotificationType.TICKET_ASSIGNED, 
      name: 'Ticket Asignado',
      description: 'Cuando se te asigna un nuevo ticket',
      category: 'ticket',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL]
    },
    {
      type: NotificationType.TICKET_UPDATED,
      name: 'Ticket Actualizado', 
      description: 'Cuando un ticket que sigues es actualizado',
      category: 'ticket',
      defaultChannels: [NotificationChannel.IN_APP]
    },
    {
      type: NotificationType.SLA_WARNING_15MIN,
      name: 'Alerta SLA 15 min',
      description: 'Cuando faltan 15 minutos para incumplir SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.SLA_WARNING_5MIN,
      name: 'Alerta SLA 5 min',
      description: 'Cuando faltan 5 minutos para incumplir SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.SLA_BREACH,
      name: 'Incumplimiento SLA',
      description: 'Cuando se incumple un SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL, NotificationChannel.SMS, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.NEW_CHAT_MESSAGE,
      name: 'Nuevo Mensaje Chat',
      description: 'Cuando recibes un mensaje en chat',
      category: 'chat',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.ESCALATION_RECEIVED,
      name: 'EscalaciÃ³n Recibida',
      description: 'Cuando recibes una escalaciÃ³n',
      category: 'escalation',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL]
    },
    {
      type: NotificationType.SATISFACTION_SURVEY,
      name: 'Encuesta SatisfacciÃ³n',
      description: 'Resultados de encuestas de satisfacciÃ³n',
      category: 'satisfaction',
      defaultChannels: [NotificationChannel.IN_APP]
    }
  ];
  
  useEffect(() => {
    loadSettings();
  }, []);
  
  const loadSettings = async () => {
    if (!user) return;
    
    try {
      setLoading(true);
      
      // Cargar configuraciones existentes
      const { data: existingSettings } = await supabase
        .from('helpdesk_notification_settings')
        .select('*')
        .eq('user_id', user.id);
      
      // Crear configuraciones por defecto para tipos que no existen
      const existingTypes = existingSettings?.map(s => s.notification_type) || [];
      const missingTypes = notificationTypes.filter(t => !existingTypes.includes(t.type));
      
      if (missingTypes.length > 0) {
        const defaultSettings = missingTypes.map(t => ({
          user_id: user.id,
          notification_type: t.type,
          enabled_channels: t.defaultChannels,
          is_enabled: true,
          batch_enabled: false,
          batch_frequency_minutes: 60
        }));
        
        await supabase
          .from('helpdesk_notification_settings')
          .insert(defaultSettings);
      }
      
      // Cargar todas las configuraciones
      const { data: allSettings, error } = await supabase
        .from('helpdesk_notification_settings')
        .select('*')
        .eq('user_id', user.id);
      
      if (error) throw error;
      
      setSettings(allSettings || []);
      
    } catch (error) {
      console.error('Error loading notification settings:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const updateSetting = async (
    notificationType: NotificationType, 
    updates: Partial<NotificationSettings>
  ) => {
    try {
      setSaving(true);
      
      const { error } = await supabase
        .from('helpdesk_notification_settings')
        .update(updates)
        .eq('user_id', user.id)
        .eq('notification_type', notificationType);
      
      if (error) throw error;
      
      // Actualizar estado local
      setSettings(prev => 
        prev.map(s => 
          s.notificationType === notificationType 
            ? { ...s, ...updates }
            : s
        )
      );
      
    } catch (error) {
      console.error('Error updating notification setting:', error);
    } finally {
      setSaving(false);
    }
  };
  
  const getSettingForType = (type: NotificationType) => {
    return settings.find(s => s.notificationType === type);
  };
  
  if (loading) {
    return (
      <div className="p-6 text-center">
        <LoadingSpinner />
        <p className="mt-2 text-gray-500">Cargando configuraciÃ³n...</p>
      </div>
    );
  }
  
  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
            ConfiguraciÃ³n de Notificaciones
          </h2>
          <p className="mt-1 text-sm text-gray-500">
            Personaliza cÃ³mo y cuÃ¡ndo recibes notificaciones del sistema Helpdesk
          </p>
        </div>
        
        <div className="p-6">
          {/* ConfiguraciÃ³n global */}
          <div className="mb-8">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              ConfiguraciÃ³n Global
            </h3>
            
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    Horas Silenciosas
                  </label>
                  <p className="text-sm text-gray-500">
                    No recibir notificaciones durante estas horas
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <input
                    type="time"
                    className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                    defaultValue="22:00"
                  />
                  <span className="text-gray-500">hasta</span>
                  <input
                    type="time"
                    className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                    defaultValue="08:00"
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-between">
                <div>
                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    DÃ­as Silenciosos
                  </label>
                  <p className="text-sm text-gray-500">
                    No recibir notificaciones estos dÃ­as
                  </p>
                </div>
                <div className="flex gap-2">
                  {['Dom', 'Lun', 'Mar', 'MiÃ©', 'Jue', 'Vie', 'SÃ¡b'].map((day, index) => (
                    <label key={day} className="flex items-center">
                      <input
                        type="checkbox"
                        className="mr-1"
                        defaultChecked={index === 0 || index === 6}
                      />
                      <span className="text-xs">{day}</span>
                    </label>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          {/* ConfiguraciÃ³n por tipo */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              ConfiguraciÃ³n por Tipo de NotificaciÃ³n
            </h3>
            
            <div className="space-y-6">
              {notificationTypes.map(notifType => {
                const setting = getSettingForType(notifType.type);
                
                return (
                  <div key={notifType.type} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                    <div className="flex items-start justify-between mb-4">
                      <div>
                        <h4 className="font-medium text-gray-900 dark:text-white">
                          {notifType.name}
                        </h4>
                        <p className="text-sm text-gray-500 mt-1">
                          {notifType.description}
                        </p>
                      </div>
                      
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={setting?.isEnabled ?? true}
                          onChange={(e) => updateSetting(notifType.type, {
                            isEnabled: e.target.checked
                          })}
                          className="mr-2"
                        />
                        <span className="text-sm">Habilitado</span>
                      </label>
                    </div>
                    
                    {setting?.isEnabled && (
                      <div className="space-y-4">
                        {/* Canales de entrega */}
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Canales de Entrega
                          </label>
                          <div className="flex flex-wrap gap-3">
                            {Object.values(NotificationChannel).map(channel => (
                              <label key={channel} className="flex items-center">
                                <input
                                  type="checkbox"
                                  checked={setting?.enabledChannels?.includes(channel) ?? false}
                                  onChange={(e) => {
                                    const currentChannels = setting?.enabledChannels || [];
                                    const newChannels = e.target.checked
                                      ? [...currentChannels, channel]
                                      : currentChannels.filter(c => c !== channel);
                                    
                                    updateSetting(notifType.type, {
                                      enabledChannels: newChannels
                                    });
                                  }}
                                  className="mr-2"
                                />
                                <span className="text-sm capitalize">
                                  {channel.replace('_', ' ')}
                                </span>
                              </label>
                            ))}
                          </div>
                        </div>
                        
                        {/* ConfiguraciÃ³n de agrupamiento */}
                        <div className="flex items-center justify-between">
                          <div>
                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                              Agrupar Notificaciones
                            </label>
                            <p className="text-sm text-gray-500">
                              Enviar notificaciones en lotes en lugar de individuales
                            </p>
                          </div>
                          <div className="flex items-center gap-2">
                            <input
                              type="checkbox"
                              checked={setting?.batchEnabled ?? false}
                              onChange={(e) => updateSetting(notifType.type, {
                                batchEnabled: e.target.checked
                              })}
                            />
                            {setting?.batchEnabled && (
                              <select
                                value={setting?.batchFrequencyMinutes || 60}
                                onChange={(e) => updateSetting(notifType.type, {
                                  batchFrequencyMinutes: parseInt(e.target.value)
                                })}
                                className="ml-2 px-2 py-1 border border-gray-300 rounded text-sm"
                              >
                                <option value={15}>15 min</option>
                                <option value={30}>30 min</option>
                                <option value={60}>1 hora</option>
                                <option value={120}>2 horas</option>
                                <option value={240}>4 horas</option>
                              </select>
                            )}
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* Botones de acciÃ³n */}
          <div className="mt-8 flex justify-end gap-3">
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
            >
              Restablecer
            </button>
            <button
              disabled={saving}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {saving ? 'Guardando...' : 'Guardar ConfiguraciÃ³n'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

**9.6 Plantillas de NotificaciÃ³n Predefinidas**

```sql
-- Insertar plantillas predefinidas para el sistema de notificaciones
INSERT INTO helpdesk_notification_templates (type, name, in_app_title, in_app_message, email_subject, email_html, priority, category, available_variables) VALUES

-- Plantillas de Tickets
('ticket_assigned', 'Ticket Asignado', 
 'Nuevo ticket asignado: {{ticketNumber}}',
 'Se te ha asignado el ticket {{ticketNumber}} - {{ticketSubject}}. Cliente: {{customerName}}',
 'Nuevo ticket asignado - {{ticketNumber}}',
 '<h2>Ticket Asignado</h2><p>Hola,</p><p>Se te ha asignado un nuevo ticket:</p><ul><li><strong>NÃºmero:</strong> {{ticketNumber}}</li><li><strong>Asunto:</strong> {{ticketSubject}}</li><li><strong>Cliente:</strong> {{customerName}}</li><li><strong>Prioridad:</strong> {{priority}}</li></ul><p>Por favor, atiende este ticket a la brevedad.</p>',
 'medium', 'ticket', 
 ARRAY['ticketNumber', 'ticketSubject', 'customerName', 'priority']),

('sla_warning_15min', 'Alerta SLA 15 Minutos',
 'SLA: {{minutesRemaining}} minutos restantes - {{ticketNumber}}',
 'AtenciÃ³n: Faltan {{minutesRemaining}} minutos para incumplir el SLA de {{slaType}} del ticket {{ticketNumber}}',
 'URGENTE: SLA prÃ³ximo a vencer - {{ticketNumber}}',
 '<h2 style="color: orange;">âš ï¸ Alerta de SLA</h2><p>El ticket {{ticketNumber}} estÃ¡ prÃ³ximo a incumplir su SLA de {{slaType}}.</p><p><strong>Tiempo restante:</strong> {{minutesRemaining}} minutos</p><p>Por favor, atiende este ticket inmediatamente.</p>',
 'high', 'sla',
 ARRAY['ticketNumber', 'minutesRemaining', 'slaType']),

('sla_breach', 'Incumplimiento SLA',
 'SLA INCUMPLIDO: {{ticketNumber}}',
 'CRÃTICO: Se ha incumplido el SLA de {{slaType}} para el ticket {{ticketNumber}}',
 'CRÃTICO: Incumplimiento de SLA - {{ticketNumber}}',
 '<h2 style="color: red;">ğŸš¨ INCUMPLIMIENTO DE SLA</h2><p>Se ha incumplido el SLA de {{slaType}} para el ticket {{ticketNumber}}.</p><p>Requiere atenciÃ³n inmediata del supervisor.</p>',
 'critical', 'sla',
 ARRAY['ticketNumber', 'slaType', 'agentName']),

-- Plantillas de Chat
('new_chat_message', 'Nuevo Mensaje Chat',
 'Mensaje de {{customerName}}',
 'Nuevo mensaje en chat: "{{messagePreview}}"',
 'Nuevo mensaje de chat - {{customerName}}',
 '<h2>Nuevo Mensaje de Chat</h2><p>Tienes un nuevo mensaje de {{customerName}}:</p><blockquote>{{messagePreview}}</blockquote><p>Tiempo de espera: {{waitTime}}</p>',
 'high', 'chat',
 ARRAY['customerName', 'messagePreview', 'waitTime']),

-- Plantillas de EscalaciÃ³n
('escalation_received', 'EscalaciÃ³n Recibida',
 'EscalaciÃ³n recibida: {{ticketNumber}}',
 'Has recibido una escalaciÃ³n del ticket {{ticketNumber}} de {{escalatedFrom}}. RazÃ³n: {{reason}}',
 'EscalaciÃ³n recibida - {{ticketNumber}}',
 '<h2>ğŸ“ˆ EscalaciÃ³n Recibida</h2><p>Has recibido una escalaciÃ³n:</p><ul><li><strong>Ticket:</strong> {{ticketNumber}}</li><li><strong>De:</strong> {{escalatedFrom}}</li><li><strong>RazÃ³n:</strong> {{reason}}</li><li><strong>Urgencia:</strong> {{urgency}}</li></ul>',
 'high', 'escalation',
 ARRAY['ticketNumber', 'escalatedFrom', 'reason', 'urgency']);
```

9.7 IntegraciÃ³n con Sistema Existente

**9.7.1 Middleware de Notificaciones**

```typescript
  const { notifications, markAsRead, markAllAsRead, deleteNotification } = useNotifications();
  
  const filteredNotifications = useMemo(() => {
    switch (filter) {
      case 'unread':
        return notifications.filter(n => !n.isRead);
      case 'high-priority':
        return notifications.filter(n => ['high', 'critical'].includes(n.priority));
      case 'actions':
        return notifications.filter(n => n.requiresAction);
      default:
        return notifications;
    }
  }, [notifications, filter]);
  
  const unreadCount = notifications.filter(n => !n.isRead).length;
  const criticalCount = notifications.filter(n => n.priority === 'critical').length;
  
  return (
    <div className="relative">
      {/* BotÃ³n de notificaciones con badge */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-900 dark:text-gray-300 hover:dark:text-white transition-colors"
      >
        <BellIcon className="h-6 w-6" />
        
        {/* Badge de notificaciones no leÃ­das */}
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full min-w-[20px]">
            {unreadCount > 99 ? '99+' : unreadCount}
          </span>
        )}
        
        {/* Indicator de notificaciones crÃ­ticas */}
        {criticalCount > 0 && (
          <span className="absolute top-0 right-0 inline-flex items-center justify-center w-3 h-3 text-xs font-bold leading-none text-white bg-red-600 rounded-full animate-pulse" />
        )}
      </button>
      
      {/* Panel de notificaciones */}
      <Transition
        show={isOpen}
        enter="transition ease-out duration-200"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <div className="absolute right-0 z-50 mt-2 w-96 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 max-h-[600px] flex flex-col">
          
          {/* Header */}
          <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Notificaciones
              </h3>
              <button
                onClick={() => setIsOpen(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-5 w-5" />
              </button>
            </div>
            
            {/* Filtros */}
            <div className="flex gap-2">
              <NotificationFilters filter={filter} setFilter={setFilter} />
              {unreadCount > 0 && (
                <button 
                  onClick={markAllAsRead}
                  className="text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                >
                  Marcar todas como leÃ­das
                </button>
              )}
            </div>
          </div>
          
          {/* Lista de notificaciones */}
          <div className="flex-1 overflow-y-auto">
            {filteredNotifications.length > 0 ? (
              <div className="divide-y divide-gray-200 dark:divide-gray-700">
                {filteredNotifications.map(notification => (
                  <NotificationItem 
                    key={notification.id}
                    notification={notification}
                    onMarkAsRead={markAsRead}
                    onDelete={deleteNotification}
                  />
                ))}
              </div>
            ) : (
              <div className="p-8 text-center text-gray-500 dark:text-gray-400">
                <BellSlashIcon className="h-12 w-12 mx-auto mb-2 text-gray-300 dark:text-gray-600" />
                <p className="text-sm">
                  {filter === 'all' ? 'No hay notificaciones' : `No hay notificaciones ${filter}`}
                </p>
              </div>
            )}
          </div>
          
          {/* Footer */}
          {filteredNotifications.length > 0 && (
            <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0">
              <button 
                onClick={() => {
                  setIsOpen(false);
                  // Navegar a pÃ¡gina completa de notificaciones
                }}
                className="w-full text-center text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 font-medium"
              >
                Ver todas las notificaciones
              </button>
            </div>
          )}
        </div>
      </Transition>
    </div>
  );
};

type NotificationFilter = 'all' | 'unread' | 'high-priority' | 'actions';

const NotificationFilters: React.FC<{
  filter: NotificationFilter;
  setFilter: (filter: NotificationFilter) => void;
}> = ({ filter, setFilter }) => {
  const filters = [
    { key: 'all', label: 'Todas', icon: InboxIcon },
    { key: 'unread', label: 'No leÃ­das', icon: EnvelopeIcon },
    { key: 'high-priority', label: 'Prioritarias', icon: ExclamationTriangleIcon },
    { key: 'actions', label: 'Acciones', icon: PlayIcon }
  ];
  
  return (
    <div className="flex gap-1">
      {filters.map(({ key, label, icon: Icon }) => (
        <button
          key={key}
          onClick={() => setFilter(key as NotificationFilter)}
          className={`px-3 py-1 text-xs font-medium rounded-full transition-colors ${
            filter === key
              ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200'
          }`}
        >
          <Icon className="h-3 w-3 inline mr-1" />
          {label}
        </button>
      ))}
    </div>
  );
};
```

**9.5.2 Item de NotificaciÃ³n**

```typescript
const NotificationItem: React.FC<{
  notification: HelpdeskNotification;
  onMarkAsRead: (id: string) => void;
  onDelete: (id: string) => void;
}> = ({ notification, onMarkAsRead, onDelete }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const handleClick = () => {
    if (!notification.isRead) {
      onMarkAsRead(notification.id);
    }
    
    if (notification.actionUrl) {
      // Navegar a la URL de acciÃ³n
      window.location.href = notification.actionUrl;
    } else {
      setIsExpanded(!isExpanded);
    }
  };
  
  const getPriorityColor = (priority: NotificationPriority) => {
    switch (priority) {
      case NotificationPriority.CRITICAL:
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
      case NotificationPriority.HIGH:
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200';
      case NotificationPriority.MEDIUM:
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
    }
  };
  
  const getCategoryIcon = (category: NotificationCategory) => {
    switch (category) {
      case NotificationCategory.TICKET:
        return TicketIcon;
      case NotificationCategory.SLA:
        return ClockIcon;
      case NotificationCategory.CHAT:
        return ChatBubbleLeftRightIcon;
      case NotificationCategory.ESCALATION:
        return ArrowTrendingUpIcon;
      case NotificationCategory.INTEGRATION:
        return LinkIcon;
      case NotificationCategory.SYSTEM:
        return CogIcon;
      case NotificationCategory.SATISFACTION:
        return StarIcon;
      default:
        return BellIcon;
    }
  };
  
  const Icon = getCategoryIcon(notification.category);
  
  return (
    <div 
      className={`p-4 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors cursor-pointer ${
        !notification.isRead ? 'bg-blue-50 dark:bg-blue-900/20' : ''
      }`}
      onClick={handleClick}
    >
      <div className="flex items-start gap-3">
        
        {/* Icono de categorÃ­a */}
        <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${
          notification.priority === NotificationPriority.CRITICAL ? 'bg-red-100 dark:bg-red-900' :
          notification.priority === NotificationPriority.HIGH ? 'bg-orange-100 dark:bg-orange-900' :
          'bg-gray-100 dark:bg-gray-700'
        }`}>
          <Icon className={`h-4 w-4 ${
            notification.priority === NotificationPriority.CRITICAL ? 'text-red-600 dark:text-red-400' :
            notification.priority === NotificationPriority.HIGH ? 'text-orange-600 dark:text-orange-400' :
            'text-gray-600 dark:text-gray-400'
          }`} />
        </div>
        
        {/* Contenido principal */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <p className={`text-sm font-medium ${
                !notification.isRead 
                  ? 'text-gray-900 dark:text-white' 
                  : 'text-gray-700 dark:text-gray-300'
              }`}>
                {notification.title}
              </p>
              
              {/* Mensaje (truncado si no estÃ¡ expandido) */}
              <p className={`text-sm text-gray-600 dark:text-gray-400 mt-1 ${
                isExpanded ? '' : 'line-clamp-2'
              }`}>
                {notification.message}
              </p>
            </div>
            
            {/* Indicador de no leÃ­do */}
            {!notification.isRead && (
              <div className="flex-shrink-0 w-2 h-2 bg-blue-600 rounded-full ml-2 mt-1"></div>
            )}
          </div>
          
          {/* Metadatos */}
          <div className="flex items-center gap-2 mt-2">
            
            {/* Badge de prioridad */}
            <span className={`inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${getPriorityColor(notification.priority)}`}>
              {notification.priority.toUpperCase()}
            </span>
            
            {/* Tiempo transcurrido */}
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {formatTimeAgo(notification.createdAt)}
            </span>
            
            {/* BotÃ³n de acciÃ³n si estÃ¡ disponible */}
            {notification.requiresAction && notification.actionLabel && (
              <span className="inline-flex items-center text-xs text-blue-600 dark:text-blue-400 font-medium">
                <PlayIcon className="h-3 w-3 mr-1" />
                {notification.actionLabel}
              </span>
            )}
          </div>
        </div>
        
        {/* MenÃº de acciones */}
        <div className="flex-shrink-0">
          <Menu as="div" className="relative">
            <Menu.Button className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
              <EllipsisHorizontalIcon className="h-4 w-4" />
            </Menu.Button>
            <Menu.Items className="absolute right-0 z-10 mt-1 w-48 bg-white dark:bg-gray-800 rounded-md shadow-lg border border-gray-200 dark:border-gray-700">
              {!notification.isRead && (
                <Menu.Item>
                  {({ active }) => (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onMarkAsRead(notification.id);
                      }}
                      className={`${
                        active ? 'bg-gray-100 dark:bg-gray-700' : ''
                      } block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300`}
                    >
                      Marcar como leÃ­da
                    </button>
                  )}
                </Menu.Item>
              )}
              <Menu.Item>
                {({ active }) => (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onDelete(notification.id);
                    }}
                    className={`${
                      active ? 'bg-gray-100 dark:bg-gray-700' : ''
                    } block w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400`}
                  >
                    Eliminar
                  </button>
                )}
              </Menu.Item>
            </Menu.Items>
          </Menu>
        </div>
      </div>
    </div>
  );
};

// FunciÃ³n auxiliar para formatear tiempo transcurrido
const formatTimeAgo = (date: Date): string => {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  
  if (diffMins < 1) return 'Ahora';
  if (diffMins < 60) return `${diffMins}m`;
  if (diffHours < 24) return `${diffHours}h`;
  if (diffDays < 7) return `${diffDays}d`;
  
  return date.toLocaleDateString();
};
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ› ï¸ 10. IMPLEMENTACIÃ“N TÃ‰CNICA

9.1 Estructura de Archivos

```
src/
â”œâ”€â”€ modules/
â”‚   â””â”€â”€ helpdesk/
â”‚       â”œâ”€â”€ components/
â”‚       â”‚   â”œâ”€â”€ Chat/
â”‚       â”‚   â”‚   â”œâ”€â”€ ChatInterface.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ MessageBubble.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ TypingIndicator.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ FileUpload.tsx
â”‚       â”‚   â”‚   â””â”€â”€ EmojiPicker.tsx
â”‚       â”‚   â”œâ”€â”€ Tickets/
â”‚       â”‚   â”‚   â”œâ”€â”€ TicketList.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ TicketCard.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ TicketFilters.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ TicketForm.tsx
â”‚       â”‚   â”‚   â””â”€â”€ TicketDetails.tsx
â”‚       â”‚   â”œâ”€â”€ Dashboard/
â”‚       â”‚   â”‚   â”œâ”€â”€ SLAWidget.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ CriticalTicketsWidget.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ WorkloadWidget.tsx
â”‚       â”‚   â”‚   â”œâ”€â”€ SatisfactionWidget.tsx
â”‚       â”‚   â”‚   â””â”€â”€ MetricsChart.tsx
â”‚       â”‚   â””â”€â”€ Admin/
â”‚       â”‚       â”œâ”€â”€ CategoryManagement.tsx
â”‚       â”‚       â”œâ”€â”€ PriorityManagement.tsx
â”‚       â”‚       â”œâ”€â”€ SLAConfiguration.tsx
â”‚       â”‚       â””â”€â”€ EscalationRules.tsx
â”‚       â”œâ”€â”€ hooks/
â”‚       â”‚   â”œâ”€â”€ useHelpdeskTickets.ts
â”‚       â”‚   â”œâ”€â”€ useHelpdeskChat.ts
â”‚       â”‚   â”œâ”€â”€ useHelpdeskMetrics.ts
â”‚       â”‚   â”œâ”€â”€ useHelpdeskSLA.ts
â”‚       â”‚   â”œâ”€â”€ useHelpdeskEscalation.ts
â”‚       â”‚   â””â”€â”€ useHelpdeskPermissions.ts
â”‚       â”œâ”€â”€ services/
â”‚       â”‚   â”œâ”€â”€ HelpdeskService.ts
â”‚       â”‚   â”œâ”€â”€ ChatService.ts
â”‚       â”‚   â”œâ”€â”€ SLAService.ts
â”‚       â”‚   â”œâ”€â”€ EscalationService.ts
â”‚       â”‚   â”œâ”€â”€ MetricsService.ts
â”‚       â”‚   â””â”€â”€ IntegrationService.ts
â”‚       â”œâ”€â”€ types/
â”‚       â”‚   â”œâ”€â”€ ticket.types.ts
â”‚       â”‚   â”œâ”€â”€ chat.types.ts
â”‚       â”‚   â”œâ”€â”€ sla.types.ts
â”‚       â”‚   â”œâ”€â”€ metrics.types.ts
â”‚       â”‚   â””â”€â”€ index.ts
â”‚       â””â”€â”€ utils/
â”‚           â”œâ”€â”€ ticketUtils.ts
â”‚           â”œâ”€â”€ slaUtils.ts
â”‚           â”œâ”€â”€ chatUtils.ts
â”‚           â””â”€â”€ metricsUtils.ts
â”œâ”€â”€ pages/
â”‚   â””â”€â”€ helpdesk/
â”‚       â”œâ”€â”€ HelpdeskDashboard.tsx
â”‚       â”œâ”€â”€ TicketsPage.tsx
â”‚       â”œâ”€â”€ ChatPage.tsx
â”‚       â”œâ”€â”€ ReportsPage.tsx
â”‚       â””â”€â”€ ConfigurationPage.tsx
â””â”€â”€ stores/
    â””â”€â”€ helpdeskStore.ts
```

9.2 Hooks Principales

9.2.1 useHelpdeskTickets
```typescript
export function useHelpdeskTickets() {
    const [tickets, setTickets] = useState<HelpdeskTicket[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [filters, setFilters] = useState<TicketFilters>({});
    const { user } = useAuth();
    
    // Cargar tickets con filtros
    const fetchTickets = useCallback(async (ticketFilters?: TicketFilters) => {
        try {
            setLoading(true);
            setError(null);
            
            let query = supabase
                .from('helpdesk_tickets')
                .select(`
                    *,
                    priority:helpdesk_priorities(*),
                    category:helpdesk_categories(*),
                    status:helpdesk_statuses(*),
                    requester:user_profiles!requester_user_id(*),
                    assigned_agent:user_profiles!assigned_agent_id(*),
                    sla_tracking:helpdesk_sla_tracking(*)
                `)
                .order('created_at', { ascending: false });
            
            // Aplicar filtros
            if (ticketFilters) {
                if (ticketFilters.status?.length) {
                    query = query.in('status_id', ticketFilters.status);
                }
                if (ticketFilters.priority?.length) {
                    query = query.in('priority_id', ticketFilters.priority);
                }
                if (ticketFilters.assignedTo?.length) {
                    query = query.in('assigned_agent_id', ticketFilters.assignedTo);
                }
                if (ticketFilters.searchTerm) {
                    query = query.or(`subject.ilike.%${ticketFilters.searchTerm}%,description.ilike.%${ticketFilters.searchTerm}%`);
                }
            }
            
            const { data, error: fetchError } = await query;
            
            if (fetchError) throw fetchError;
            
            const mappedTickets = data.map(mapTicketFromDB);
            setTickets(mappedTickets);
            
        } catch (err) {
            console.error('Error fetching tickets:', err);
            setError(err instanceof Error ? err.message : 'Error desconocido');
        } finally {
            setLoading(false);
        }
    }, []);
    
    // Crear nuevo ticket
    const createTicket = async (ticketData: CreateTicketData): Promise<HelpdeskTicket | null> => {
        try {
            const { data, error } = await supabase
                .from('helpdesk_tickets')
                .insert({
                    subject: ticketData.subject,
                    description: ticketData.description,
                    priority_id: ticketData.priorityId,
                    category_id: ticketData.categoryId,
                    requester_user_id: user?.id,
                    source_type: 'chat'
                })
                .select()
                .single();
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return mapTicketFromDB(data);
            
        } catch (err) {
            console.error('Error creating ticket:', err);
            setError(err instanceof Error ? err.message : 'Error al crear ticket');
            return null;
        }
    };
    
    // Asignar ticket
    const assignTicket = async (ticketId: string, agentId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_tickets')
                .update({ 
                    assigned_agent_id: agentId,
                    updated_at: new Date().toISOString()
                })
                .eq('id', ticketId);
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return true;
            
        } catch (err) {
            console.error('Error assigning ticket:', err);
            setError(err instanceof Error ? err.message : 'Error al asignar ticket');
            return false;
        }
    };
    
    // Actualizar estado del ticket
    const updateTicketStatus = async (ticketId: string, statusId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_tickets')
                .update({ 
                    status_id: statusId,
                    updated_at: new Date().toISOString()
                })
                .eq('id', ticketId);
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return true;
            
        } catch (err) {
            console.error('Error updating ticket status:', err);
            setError(err instanceof Error ? err.message : 'Error al actualizar estado');
            return false;
        }
    };
    
    useEffect(() => {
        fetchTickets(filters);
    }, [fetchTickets, filters]);
    
    return {
        tickets,
        loading,
        error,
        filters,
        setFilters,
        fetchTickets,
        createTicket,
        assignTicket,
        updateTicketStatus,
        // Utilities
        getTicketById: (id: string) => tickets.find(t => t.id === id),
        getMyTickets: () => tickets.filter(t => t.assignedAgent?.id === user?.id),
        getUnassignedTickets: () => tickets.filter(t => !t.assignedAgent),
        getCriticalTickets: () => tickets.filter(t => t.priority.level === 1)
    };
}
```

9.2.2 useHelpdeskChat
```typescript
export function useHelpdeskChat(ticketId: string) {
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isTyping, setIsTyping] = useState(false);
    const [typingUsers, setTypingUsers] = useState<User[]>([]);
    const { user } = useAuth();
    
    // Cargar mensajes del ticket
    const fetchMessages = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            
            const { data, error: fetchError } = await supabase
                .from('helpdesk_chat_messages')
                .select(`
                    *,
                    sender:user_profiles(*)
                `)
                .eq('ticket_id', ticketId)
                .order('created_at', { ascending: true });
            
            if (fetchError) throw fetchError;
            
            const mappedMessages = data.map(mapMessageFromDB);
            setMessages(mappedMessages);
            
        } catch (err) {
            console.error('Error fetching messages:', err);
            setError(err instanceof Error ? err.message : 'Error al cargar mensajes');
        } finally {
            setLoading(false);
        }
    }, [ticketId]);
    
    // Enviar mensaje
    const sendMessage = async (content: string, messageType: MessageType = 'text', isInternal = false): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_chat_messages')
                .insert({
                    ticket_id: ticketId,
                    sender_user_id: user?.id,
                    message_type: messageType,
                    content,
                    is_internal: isInternal
                });
            
            if (error) throw error;
            
            return true;
            
        } catch (err) {
            console.error('Error sending message:', err);
            setError(err instanceof Error ? err.message : 'Error al enviar mensaje');
            return false;
        }
    };
    
    // Configurar suscripciÃ³n en tiempo real
    useEffect(() => {
        const channel = supabase
            .channel(`chat_${ticketId}`)
            .on('postgres_changes', 
                { 
                    event: 'INSERT', 
                    schema: 'public', 
                    table: 'helpdesk_chat_messages',
                    filter: `ticket_id=eq.${ticketId}`
                },
                async (payload) => {
                    const newMessage = await fetchMessageDetails(payload.new.id);
                    if (newMessage) {
                        setMessages(prev => [...prev, newMessage]);
                    }
                }
            )
            .subscribe();
        
        return () => {
            supabase.removeChannel(channel);
        };
    }, [ticketId]);
    
    // Cargar mensajes al montar
    useEffect(() => {
        fetchMessages();
    }, [fetchMessages]);
    
    return {
        messages,
        loading,
        error,
        isTyping,
        typingUsers,
        sendMessage,
        refreshMessages: fetchMessages,
        // Utilities
        getLastMessage: () => messages[messages.length - 1],
        getMessagesByType: (type: MessageType) => messages.filter(m => m.messageType === type),
        getInternalMessages: () => messages.filter(m => m.isInternal)
    };
}
```

9.3 Servicios

9.3.1 SLA Service
```typescript
class SLAService {
    async calculateSLAForTicket(ticket: HelpdeskTicket): Promise<SLACalculation> {
        const { data: slaSettings } = await supabase
            .rpc('calculate_sla_dates', {
                p_priority_id: ticket.priority.id,
                p_category_id: ticket.category.id,
                p_created_at: ticket.createdAt
            });
        
        const now = new Date();
        const firstResponseDue = new Date(slaSettings.first_response_due);
        const resolutionDue = new Date(slaSettings.resolution_due);
        
        return {
            firstResponse: {
                dueDate: firstResponseDue,
                status: this.getSLAStatus(ticket.firstResponseAt, firstResponseDue, now),
                timeRemaining: Math.max(0, firstResponseDue.getTime() - now.getTime()) / 60000
            },
            resolution: {
                dueDate: resolutionDue,
                status: this.getSLAStatus(ticket.resolutionDate, resolutionDue, now),
                timeRemaining: Math.max(0, resolutionDue.getTime() - now.getTime()) / 60000
            }
        };
    }
    
    private getSLAStatus(actualDate: Date | null, dueDate: Date, currentDate: Date): SLAStatus {
        if (actualDate) {
            return actualDate <= dueDate ? 'compliant' : 'breached';
        }
        
        const timeRemaining = dueDate.getTime() - currentDate.getTime();
        const warningThreshold = 20 * 60 * 1000; // 20 minutos
        
        if (timeRemaining <= 0) return 'breached';
        if (timeRemaining <= warningThreshold) return 'at_risk';
        return 'compliant';
    }
    
    async updateSLATracking(ticketId: string, eventType: SLAEventType): Promise<void> {
        await supabase
            .from('helpdesk_sla_tracking')
            .update({
                achieved_date: new Date().toISOString(),
                is_breached: false,
                updated_at: new Date().toISOString()
            })
            .eq('ticket_id', ticketId)
            .eq('sla_type', eventType);
    }
}
```

9.3.2 Escalation Service
```typescript
class EscalationService {
    async processAutomaticEscalations(): Promise<void> {
        const rules = await this.getActiveEscalationRules();
        const candidateTickets = await this.getEscalationCandidates();
        
        for (const ticket of candidateTickets) {
            for (const rule of rules) {
                if (await this.shouldEscalate(ticket, rule)) {
                    await this.executeEscalation(ticket, rule);
                }
            }
        }
    }
    
    private async shouldEscalate(ticket: HelpdeskTicket, rule: EscalationRule): Promise<boolean> {
        switch (rule.trigger.type) {
            case 'time_based':
                const timeSinceCreation = Date.now() - new Date(ticket.createdAt).getTime();
                return timeSinceCreation > (rule.trigger.conditions.timeThresholdMinutes || 0) * 60000;
                
            case 'sla_breach':
                const slaCalculation = await new SLAService().calculateSLAForTicket(ticket);
                return rule.trigger.conditions.slaType === 'first_response' 
                    ? slaCalculation.firstResponse.status === 'breached'
                    : slaCalculation.resolution.status === 'breached';
                    
            case 'priority_based':
                return ticket.priority.level <= (rule.trigger.conditions.priorityLevel || 5);
                
            default:
                return false;
        }
    }
    
    private async executeEscalation(ticket: HelpdeskTicket, rule: EscalationRule): Promise<void> {
        // Registrar escalaciÃ³n
        await supabase
            .from('helpdesk_escalations')
            .insert({
                ticket_id: ticket.id,
                escalation_type: rule.trigger.type,
                from_user_id: ticket.assignedAgent?.id,
                to_user_id: rule.action.targetId,
                reason: `EscalaciÃ³n automÃ¡tica: ${rule.name}`
            });
        
        // Actualizar ticket
        await supabase
            .from('helpdesk_tickets')
            .update({
                assigned_agent_id: rule.action.targetId,
                escalated_to_user_id: rule.action.targetId,
                updated_at: new Date().toISOString()
            })
            .eq('id', ticket.id);
        
        // Enviar notificaciones
        await this.sendEscalationNotifications(ticket, rule);
    }
}
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš€ 10. PLAN DE IMPLEMENTACIÃ“N

10.1 Cronograma de Desarrollo

**FASE 1: FUNDACIÃ“N (4-6 semanas)**
```
Semana 1-2: Infraestructura Base
â”œâ”€â”€ DiseÃ±o de base de datos y migraciones
â”œâ”€â”€ ConfiguraciÃ³n de entorno de desarrollo  
â”œâ”€â”€ Setup de Supabase Realtime
â””â”€â”€ ImplementaciÃ³n de autenticaciÃ³n bÃ¡sica

Semana 3-4: Componentes Core
â”œâ”€â”€ Estructura de archivos del mÃ³dulo
â”œâ”€â”€ Tipos TypeScript bÃ¡sicos
â”œâ”€â”€ Hooks fundamentales (useHelpdeskTickets, useHelpdeskChat)
â””â”€â”€ Servicios base (HelpdeskService, ChatService)

Semana 5-6: Chat BÃ¡sico
â”œâ”€â”€ Interfaz de chat en tiempo real
â”œâ”€â”€ Sistema de mensajes bÃ¡sico
â”œâ”€â”€ Soporte para archivos adjuntos
â””â”€â”€ Indicadores de escritura
```

**FASE 2: FUNCIONALIDADES CORE (6-8 semanas)**
```
Semana 7-9: Sistema de Tickets
â”œâ”€â”€ CRUD completo de tickets
â”œâ”€â”€ Sistema de estados y transiciones
â”œâ”€â”€ Filtros y bÃºsqueda avanzada
â”œâ”€â”€ Vista Kanban y lista

Semana 10-12: SLA Management
â”œâ”€â”€ ConfiguraciÃ³n de SLA por prioridad/categorÃ­a
â”œâ”€â”€ CÃ¡lculo automÃ¡tico de fechas SLA
â”œâ”€â”€ Tracking y alertas de SLA
â”œâ”€â”€ Dashboard de mÃ©tricas SLA

Semana 13-14: Sistema de EscalaciÃ³n
â”œâ”€â”€ Motor de reglas de escalaciÃ³n
â”œâ”€â”€ EscalaciÃ³n automÃ¡tica y manual
â”œâ”€â”€ Notificaciones de escalaciÃ³n
â”œâ”€â”€ Tracking de cadena de escalaciÃ³n
```

**FASE 3: CARACTERÃSTICAS AVANZADAS (4-6 semanas)**
```
Semana 15-17: IntegraciÃ³n con Casos
â”œâ”€â”€ ConversiÃ³n ticket â†’ caso
â”œâ”€â”€ SincronizaciÃ³n bidireccional de estados
â”œâ”€â”€ API de integraciÃ³n
â”œâ”€â”€ Clasificador de complejidad

Semana 18-20: Dashboard y Reportes
â”œâ”€â”€ Widgets especializados
â”œâ”€â”€ Reportes de performance
â”œâ”€â”€ AnÃ¡lisis de tendencias
â”œâ”€â”€ ExportaciÃ³n de datos
```

**FASE 4: OPTIMIZACIÃ“N Y DESPLIEGUE (2-4 semanas)**
```
Semana 21-22: Testing y OptimizaciÃ³n
â”œâ”€â”€ Tests unitarios (>85% coverage)
â”œâ”€â”€ Tests de integraciÃ³n
â”œâ”€â”€ OptimizaciÃ³n de performance
â”œâ”€â”€ Testing de carga

Semana 23-24: Despliegue y DocumentaciÃ³n
â”œâ”€â”€ DocumentaciÃ³n de usuario
â”œâ”€â”€ DocumentaciÃ³n tÃ©cnica
â”œâ”€â”€ Despliegue en producciÃ³n
â”œâ”€â”€ Monitoreo y alertas
```

10.2 Fases de ImplementaciÃ³n

**ğŸ“‹ FASE 1: FUNDACIÃ“N**

*Objetivo: Establecer la base tÃ©cnica sÃ³lida*

**Entregables:**
- âœ… Base de datos completamente diseÃ±ada y migrada
- âœ… AutenticaciÃ³n y autorizaciÃ³n funcionando
- âœ… Chat bÃ¡sico en tiempo real operativo
- âœ… Estructura de archivos y componentes base

**Criterios de AceptaciÃ³n:**
- Los usuarios pueden crear tickets bÃ¡sicos
- El chat funciona en tiempo real entre usuarios
- La autenticaciÃ³n respeta los nuevos roles de HELPDESK
- Las migraciones se ejecutan sin errores

**ğŸ“Š FASE 2: FUNCIONALIDADES CORE**

*Objetivo: Implementar todas las funcionalidades principales*

**Entregables:**
- âœ… Sistema completo de gestiÃ³n de tickets
- âœ… SLA management completamente funcional
- âœ… Motor de escalaciÃ³n automÃ¡tica
- âœ… Dashboard bÃ¡sico con mÃ©tricas principales

**Criterios de AceptaciÃ³n:**
- Los tickets se pueden gestionar completamente (CRUD)
- El SLA se calcula y monitorea automÃ¡ticamente
- Las escalaciones funcionan segÃºn reglas configuradas
- Las mÃ©tricas se muestran en tiempo real

**ğŸ”„ FASE 3: INTEGRACIÃ“N**

*Objetivo: Conectar perfectamente con mÃ³dulos existentes*

**Entregables:**
- âœ… IntegraciÃ³n completa con mÃ³dulo de Casos
- âœ… SincronizaciÃ³n bidireccional de estados
- âœ… API REST completa para integraciones
- âœ… Dashboard avanzado con reportes

**Criterios de AceptaciÃ³n:**
- Los tickets se convierten a casos sin pÃ©rdida de datos
- Los cambios en casos se reflejan en tickets
- La API permite integraciones externas
- Los reportes son precisos y Ãºtiles

**ğŸš€ FASE 4: OPTIMIZACIÃ“N**

*Objetivo: Preparar para producciÃ³n y optimizar performance*

**Entregables:**
- âœ… Suite completa de tests
- âœ… Optimizaciones de performance
- âœ… DocumentaciÃ³n completa
- âœ… Sistema en producciÃ³n

**Criterios de AceptaciÃ³n:**
- Coverage de tests > 85%
- Tiempo de respuesta < 100ms
- DocumentaciÃ³n tÃ©cnica completa
- Sistema estable en producciÃ³n

10.3 Recursos Necesarios

**ğŸ‘¥ EQUIPO DE DESARROLLO**

```
Rol                    | AsignaciÃ³n | Responsabilidades
-----------------------|------------|------------------
Tech Lead             | 1 persona  | Arquitectura, decisiones tÃ©cnicas
Frontend Developer    | 2 personas | React, TypeScript, UI/UX
Backend Developer     | 1 persona  | Supabase, SQL, API
UX/UI Designer        | 1 persona  | DiseÃ±o de interfaces, usabilidad
QA Engineer           | 1 persona  | Testing, calidad
DevOps Engineer       | 0.5 persona| Despliegue, monitoreo
Product Owner         | 0.5 persona| Requisitos, priorizaciÃ³n
```

**ğŸ’» INFRAESTRUCTURA TÃ‰CNICA**

```
Recurso               | EspecificaciÃ³n
---------------------|------------------
Supabase Pro         | Base de datos, Auth, Realtime
GitHub                | Control de versiones
Netlify Pro          | Hosting y CI/CD
Figma                | DiseÃ±o y prototipado
Notion               | DocumentaciÃ³n del proyecto
```

**ğŸ“Š PRESUPUESTO ESTIMADO**

```
CategorÃ­a            | Costo Mensual | Costo Total (6 meses)
--------------------|---------------|----------------------
Equipo (6 personas) | $25,000       | $150,000
Infraestructura     | $500          | $3,000
Herramientas        | $300          | $1,800
Contingencia (10%)  | $2,580        | $15,480
--------------------|---------------|----------------------
TOTAL               | $28,380       | $170,280
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“ 11. APÃ‰NDICES

11.1 Glosario de TÃ©rminos

**ANS (Acuerdo de Nivel de Servicio)**: Compromisos especÃ­ficos de tiempo y calidad para la resoluciÃ³n de tickets.

**EscalaciÃ³n**: Proceso de elevar un ticket a un nivel superior de soporte cuando no puede resolverse en el nivel actual.

**FCR (First Call Resolution)**: MÃ©trica que indica el porcentaje de tickets resueltos en el primer contacto.

**HELPDESK**: Sistema centralizado para gestiÃ³n de solicitudes de soporte tÃ©cnico y servicios.

**SLA (Service Level Agreement)**: Acuerdo que define los tiempos mÃ¡ximos de respuesta y resoluciÃ³n.

**Ticket**: Registro individual de una solicitud de soporte con nÃºmero Ãºnico de identificaciÃ³n.

**WebSocket**: Protocolo de comunicaciÃ³n bidireccional para chat en tiempo real.

11.2 Referencias TÃ©cnicas

**DocumentaciÃ³n de APIs:**
- Supabase Documentation: https://supabase.io/docs
- React Query v4: https://tanstack.com/query/v4
- Zustand State Management: https://github.com/pmndrs/zustand
- Tailwind CSS: https://tailwindcss.com/docs

**EstÃ¡ndares y Mejores PrÃ¡cticas:**
- ITIL 4 Framework para gestiÃ³n de servicios
- TypeScript Handbook: https://www.typescriptlang.org/docs/
- React Best Practices: https://react.dev/learn
- PostgreSQL Performance Tuning Guide

**Herramientas de Desarrollo:**
- VS Code con extensiones React/TypeScript
- GitHub Actions para CI/CD
- Figma para diseÃ±o de interfaces
- Postman para testing de APIs

11.3 Casos de Uso Detallados

**CU-001: Cliente Crea Ticket VÃ­a Chat**
```
Actor: Cliente (helpdesk_customer)
Precondiciones: Usuario autenticado en el sistema

Flujo Principal:
1. Cliente accede al portal de HELPDESK
2. Sistema muestra interfaz de chat
3. Cliente escribe su consulta/problema
4. Sistema crea automÃ¡ticamente un ticket con nÃºmero Ãºnico
5. Sistema asigna prioridad y categorÃ­a automÃ¡ticamente
6. Sistema calcula fechas SLA
7. Sistema busca agente disponible y asigna ticket
8. Agente recibe notificaciÃ³n de nuevo ticket
9. Chat queda establecido entre cliente y agente

Flujos Alternativos:
3a. Cliente adjunta archivos (capturas, logs)
5a. Sistema no puede determinar categorÃ­a automÃ¡ticamente
    - Ticket queda en cola para clasificaciÃ³n manual
8a. No hay agentes disponibles
    - Ticket queda en cola general
    - Cliente recibe mensaje estimado de tiempo de espera

Postcondiciones: 
- Ticket creado y asignado
- Chat activo entre cliente y agente
- SLA iniciado y monitoreado
```

**CU-002: Agente Resuelve Ticket y Convierte a Caso**
```
Actor: Agente L3 (helpdesk_agent_l3)
Precondiciones: Ticket asignado al agente, requiere anÃ¡lisis complejo

Flujo Principal:
1. Agente revisa ticket y determina complejidad alta
2. Agente accede al clasificador de casos
3. Sistema presenta formulario de clasificaciÃ³n
4. Agente completa criterios de complejidad:
   - Historial del caso
   - Conocimiento del mÃ³dulo
   - ManipulaciÃ³n de datos
   - Claridad de descripciÃ³n
   - Causa del fallo
5. Sistema calcula puntuaciÃ³n automÃ¡ticamente
6. Sistema determina clasificaciÃ³n (Alta/Media/Baja complejidad)
7. Agente confirma conversiÃ³n a caso
8. Sistema crea caso en mÃ³dulo existente
9. Sistema vincula ticket con caso creado
10. Sistema actualiza estado ticket a "CLASSIFIED_TO_CASE"
11. Sistema envÃ­a notificaciÃ³n al equipo de casos

Postcondiciones:
- Caso creado en mÃ³dulo de gestiÃ³n
- Ticket vinculado al caso
- Seguimiento transferido a equipo especializado
```

**CU-003: Dashboard de Manager - AnÃ¡lisis de SLA**
```
Actor: Manager de HELPDESK (helpdesk_manager)
Precondiciones: Usuario con permisos de manager

Flujo Principal:
1. Manager accede al dashboard especializado
2. Sistema muestra widgets principales:
   - Cumplimiento SLA general
   - Tickets crÃ­ticos pendientes
   - DistribuciÃ³n de carga por agente
   - SatisfacciÃ³n del cliente
3. Manager selecciona perÃ­odo especÃ­fico (dÃ­a/semana/mes)
4. Sistema actualiza mÃ©tricas en tiempo real
5. Manager identifica Ã¡reas de mejora
6. Manager accede a reportes detallados
7. Sistema genera anÃ¡lisis de tendencias
8. Manager exporta reportes para presentaciÃ³n

CaracterÃ­sticas Especiales:
- ActualizaciÃ³n automÃ¡tica cada 30 segundos
- Alertas visuales para SLA en riesgo
- Drill-down en mÃ©tricas especÃ­ficas
- ComparaciÃ³n con perÃ­odos anteriores
```

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ¯ CONCLUSIÃ“N

El mÃ³dulo HELPDESK representa una **transformaciÃ³n estratÃ©gica** del sistema de gestiÃ³n de casos, elevÃ¡ndolo de una herramienta de gestiÃ³n interna a una **plataforma integral de atenciÃ³n al cliente** con capacidades empresariales.

**ğŸ”‘ FACTORES CRÃTICOS DE Ã‰XITO:**

1. **AdopciÃ³n Gradual**: ImplementaciÃ³n por fases permitirÃ¡ adaptaciÃ³n del equipo
2. **Training Integral**: CapacitaciÃ³n completa en nuevos procesos y herramientas
3. **MÃ©tricas Claras**: KPIs bien definidos para medir Ã©xito del proyecto
4. **Feedback Continuo**: Ciclos de retroalimentaciÃ³n con usuarios finales
5. **Soporte Post-Launch**: AcompaÃ±amiento durante primeros meses

**ğŸ“ˆ IMPACTO PROYECTADO:**

- **Eficiencia Operacional**: ReducciÃ³n 40% tiempo de primera respuesta
- **SatisfacciÃ³n Cliente**: Incremento 35% en CSAT scores
- **Visibilidad Gerencial**: 100% visibilidad en mÃ©tricas operacionales
- **Escalabilidad**: Capacidad para 10x crecimiento en volumen

**ğŸš€ PRÃ“XIMOS PASOS:**

1. **AprobaciÃ³n del Proyecto**: RevisiÃ³n y aprobaciÃ³n de especificaciÃ³n
2. **Setup del Equipo**: ContrataciÃ³n y organizaciÃ³n del equipo
3. **Kick-off Meeting**: ReuniÃ³n de inicio con todos los stakeholders
4. **Sprint Planning**: PlanificaciÃ³n detallada de primeros sprints

---

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”— 12. INTEGRACIÃ“N CON SISTEMA EXISTENTE

12.1 Arquitectura de IntegraciÃ³n

El mÃ³dulo HELPDESK se integra perfectamente con el sistema existente de gestiÃ³n de casos a travÃ©s de mÃºltiples puntos de conexiÃ³n, manteniendo la coherencia arquitectÃ³nica y aprovechando la infraestructura actual.

**12.1.1 Diagrama de IntegraciÃ³n**
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SISTEMA CASE MANAGEMENT                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚   MÃ“DULO CASOS  â”‚    MÃ“DULO HELPDESK        â”‚  MÃ“DULOS ADMIN    â”‚
â”‚                 â”‚                           â”‚                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚ â”‚    Cases    â”‚â—„â”¼â–ºâ”‚       Tickets           â”‚ â”‚ â”‚    Users    â”‚ â”‚
â”‚ â”‚             â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚             â”‚ â”‚
â”‚ â”‚ CaseControl â”‚â—„â”¼â–ºâ”‚    Chat Messages        â”‚ â”‚ â”‚    Roles    â”‚ â”‚
â”‚ â”‚             â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚             â”‚ â”‚
â”‚ â”‚    Notes    â”‚â—„â”¼â–ºâ”‚    SLA Tracking         â”‚ â”‚ â”‚   Archive   â”‚ â”‚
â”‚ â”‚             â”‚ â”‚ â”‚                         â”‚ â”‚ â”‚             â”‚ â”‚
â”‚ â”‚    Todos    â”‚â—„â”¼â–ºâ”‚    Escalations          â”‚ â”‚ â”‚  Cleanup    â”‚ â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   SHARED LAYER    â”‚
                    â”‚                   â”‚
                    â”‚  â€¢ Supabase DB    â”‚
                    â”‚  â€¢ Authentication â”‚
                    â”‚  â€¢ RLS Policies   â”‚
                    â”‚  â€¢ Realtime       â”‚
                    â”‚  â€¢ File Storage   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**12.1.2 Puntos de IntegraciÃ³n**

**a) Base de Datos Compartida**
- Utiliza la misma instancia de Supabase PostgreSQL
- Comparte tablas de usuarios (`user_profiles`)
- Reutiliza sistema de roles existente
- Aprovecha polÃ­ticas RLS establecidas

**b) AutenticaciÃ³n Unificada**
- Extiende roles existentes con permisos HELPDESK
- Mantiene sesiÃ³n Ãºnica entre mÃ³dulos
- Reutiliza componentes de autenticaciÃ³n (`AuthForm`, `ProtectedRoute`)

**c) Interfaz de Usuario Cohesiva**
- Integra con layout existente (`Layout.tsx`)
- Utiliza sistema de temas compartido (`themeStore.ts`)
- Aprovecha componentes base (`Button`, `Input`, `Modal`, `Select`)

**d) Sistema de Notificaciones Integrado**
- Extiende componente `NotificationSystem` existente
- Reutiliza infraestructura de Supabase Realtime
- Integra con bandeja de notificaciones unificada
- Comparte polÃ­ticas RLS para seguridad

12.2 ReutilizaciÃ³n de Componentes Existentes

**12.2.1 Componentes Base Reutilizados**
```typescript
// Componentes del sistema actual que HELPDESK aprovecha
import { Layout } from '../components/Layout';
import { Button } from '../components/Button';
import { Input } from '../components/Input';
import { Select } from '../components/Select';
import { Modal } from '../components/Modal';
import { LoadingSpinner } from '../components/LoadingSpinner';
import { ConfirmationModal } from '../components/ConfirmationModal';
import { NotificationSystem } from '../components/NotificationSystem';
import { ThemeToggle } from '../components/ThemeToggle';
import { PageWrapper } from '../components/PageWrapper';

// Hooks compartidos
import { useAuth } from '../hooks/useAuth';
import { usePermissions } from '../hooks/usePermissions';
import { useUsers } from '../hooks/useUsers';
import { useRoles } from '../hooks/useRoles';

// Stores compartidos
import { useThemeStore } from '../stores/themeStore';

// Utilidades compartidas
import { supabase } from '../lib/supabase';
import { validateInput } from '../lib/validations';
```

**12.2.2 ExtensiÃ³n del Sistema de NavegaciÃ³n**
```typescript
// ExtensiÃ³n de Layout.tsx para incluir navegaciÃ³n HELPDESK
const navigationItems = [
  // NavegaciÃ³n existente
  { name: 'Dashboard', href: '/dashboard', icon: HomeIcon },
  { name: 'Casos', href: '/cases', icon: FolderIcon },
  { name: 'Notas', href: '/notes', icon: DocumentTextIcon },
  { name: 'Todos', href: '/todos', icon: CheckCircleIcon },
  
  // Nueva navegaciÃ³n HELPDESK
  {
    name: 'HELPDESK',
    icon: ChatBubbleLeftRightIcon,
    children: [
      { name: 'Dashboard', href: '/helpdesk/dashboard' },
      { name: 'Tickets', href: '/helpdesk/tickets' },
      { name: 'Chat', href: '/helpdesk/chat' },
      { name: 'Reportes', href: '/helpdesk/reports' },
      { name: 'ConfiguraciÃ³n', href: '/helpdesk/config' }
    ]
  },
  
  // NavegaciÃ³n de administraciÃ³n (existente)
  { name: 'Archivo', href: '/archive', icon: ArchiveBoxIcon },
  { name: 'Admin', href: '/admin', icon: CogIcon }
];
```

12.3 ExtensiÃ³n del Sistema de Roles

**12.3.1 Nuevos Roles de HELPDESK**
```sql
-- ExtensiÃ³n de tabla roles existente
INSERT INTO roles (name, description, permissions) VALUES
('helpdesk_customer', 'Cliente de HELPDESK', ARRAY[
  'helpdesk.tickets.create',
  'helpdesk.tickets.view_own',
  'helpdesk.chat.send_messages',
  'helpdesk.chat.view_own'
]),
('helpdesk_agent_l1', 'Agente HELPDESK Nivel 1', ARRAY[
  'helpdesk.tickets.view_assigned',
  'helpdesk.tickets.update_status',
  'helpdesk.chat.send_messages',
  'helpdesk.chat.view_assigned',
  'helpdesk.escalation.create'
]),
('helpdesk_agent_l2', 'Agente HELPDESK Nivel 2', ARRAY[
  'helpdesk.tickets.view_team',
  'helpdesk.tickets.assign',
  'helpdesk.tickets.classify_to_case',
  'helpdesk.chat.send_internal',
  'helpdesk.sla.manage'
]),
('helpdesk_agent_l3', 'Agente HELPDESK Nivel 3', ARRAY[
  'helpdesk.tickets.view_all',
  'helpdesk.tickets.manage_all',
  'helpdesk.cases.create_from_ticket',
  'helpdesk.escalation.manage'
]),
('helpdesk_supervisor', 'Supervisor HELPDESK', ARRAY[
  'helpdesk.team.manage',
  'helpdesk.metrics.view_team',
  'helpdesk.reports.generate'
]),
('helpdesk_manager', 'Manager HELPDESK', ARRAY[
  'helpdesk.admin.full',
  'helpdesk.metrics.view_all',
  'helpdesk.config.manage',
  'helpdesk.reports.executive'
]);
```

**12.3.2 IntegraciÃ³n con Sistema de Permisos Existente**
```typescript
// ExtensiÃ³n del hook usePermissions existente
export function useHelpdeskPermissions() {
  const { user, permissions } = usePermissions();
  
  return {
    // Permisos especÃ­ficos de HELPDESK
    canCreateTickets: permissions.includes('helpdesk.tickets.create'),
    canViewAllTickets: permissions.includes('helpdesk.tickets.view_all'),
    canAssignTickets: permissions.includes('helpdesk.tickets.assign'),
    canClassifyToCases: permissions.includes('helpdesk.tickets.classify_to_case'),
    canCreateCasesFromTickets: permissions.includes('helpdesk.cases.create_from_ticket'),
    canSendInternalMessages: permissions.includes('helpdesk.chat.send_internal'),
    canManageSLA: permissions.includes('helpdesk.sla.manage'),
    canViewMetrics: permissions.includes('helpdesk.metrics.view_team') || 
                   permissions.includes('helpdesk.metrics.view_all'),
    canManageConfig: permissions.includes('helpdesk.config.manage'),
    
    // MÃ©todos de utilidad
    isHelpdeskUser: () => user?.role?.name.startsWith('helpdesk_'),
    isHelpdeskAgent: () => user?.role?.name.startsWith('helpdesk_agent_'),
    isHelpdeskSupervisor: () => ['helpdesk_supervisor', 'helpdesk_manager'].includes(user?.role?.name),
    getHelpdeskLevel: () => {
      if (user?.role?.name === 'helpdesk_agent_l1') return 1;
      if (user?.role?.name === 'helpdesk_agent_l2') return 2;
      if (user?.role?.name === 'helpdesk_agent_l3') return 3;
      return 0;
    }
  };
}
```

12.4 SincronizaciÃ³n de Datos

**12.4.1 Flujo de ConversiÃ³n Ticket â†’ Caso**
```typescript
// Servicio de integraciÃ³n que conecta ambos mÃ³dulos
class TicketCaseIntegrationService {
  async convertTicketToCase(ticketId: string, classification: CaseClassification): Promise<Case> {
    const ticket = await this.helpdeskService.getTicket(ticketId);
    
    // Reutilizar la lÃ³gica existente de creaciÃ³n de casos
    const caseData: CreateCaseData = {
      numeroCaso: await this.generateCaseNumber(), // Reutiliza funciÃ³n existente
      descripcion: `[HELPDESK #${ticket.ticketNumber}] ${ticket.subject}\n\n${ticket.description}`,
      fecha: new Date().toISOString().split('T')[0],
      origenId: await this.getHelpdeskOriginId(), // Nuevo origen "HELPDESK"
      aplicacionId: classification.applicationId,
      
      // Reutilizar sistema de clasificaciÃ³n existente
      historialCaso: classification.historialCaso,
      conocimientoModulo: classification.conocimientoModulo,
      manipulacionDatos: classification.manipulacionDatos,
      claridadDescripcion: classification.claridadDescripcion,
      causaFallo: classification.causaFallo,
      userId: ticket.assignedAgentId
    };
    
    // Usar funciones de validaciÃ³n existentes
    caseData.puntuacion = calcularPuntuacion(caseData); // FunciÃ³n existente
    caseData.clasificacion = clasificarCaso(caseData.puntuacion); // FunciÃ³n existente
    
    // Crear caso usando servicio existente
    const createdCase = await this.casesService.createCase(caseData);
    
    // Crear vÃ­nculo en tabla de integraciÃ³n
    await this.createTicketCaseLink(ticketId, createdCase.id);
    
    // Sincronizar notas del chat como notas del caso
    await this.syncChatToNotes(ticketId, createdCase.id);
    
    return createdCase;
  }
  
  private async syncChatToNotes(ticketId: string, caseId: string): Promise<void> {
    const chatMessages = await this.helpdeskService.getChatMessages(ticketId);
    
    for (const message of chatMessages) {
      if (!message.isInternal) { // Solo mensajes no internos
        await this.notesService.createNote({
          caseId: caseId,
          titulo: `Chat HELPDESK - ${message.sender.name}`,
          contenido: message.content,
          usuarioId: message.senderId,
          fechaCreacion: message.createdAt
        });
      }
    }
  }
}
```

**12.4.2 SincronizaciÃ³n Bidireccional**
```typescript
// Listener que mantiene sincronizados los estados
class StateSyncService {
  constructor() {
    this.setupRealtimeSync();
  }
  
  private setupRealtimeSync(): void {
    // Escuchar cambios en casos para actualizar tickets vinculados
    supabase
      .channel('case_status_sync')
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'case_control'
      }, async (payload) => {
        await this.syncCaseStatusToTicket(payload.new);
      })
      .subscribe();
    
    // Escuchar cambios en tickets para actualizar casos vinculados
    supabase
      .channel('ticket_status_sync')
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, async (payload) => {
        await this.syncTicketStatusToCase(payload.new);
      })
      .subscribe();
  }
}
```

12.5 Dashboard Unificado

**12.5.1 ExtensiÃ³n del Dashboard Principal**
```typescript
// IntegraciÃ³n de widgets HELPDESK en dashboard existente
const DashboardPage = () => {
  const { user } = useAuth();
  const { isHelpdeskUser } = useHelpdeskPermissions();
  
  return (
    <PageWrapper title="Dashboard">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        
        {/* Widgets existentes */}
        <CasesMetricsWidget />
        <NotesQuickAccess />
        <TodosSummary />
        
        {/* Nuevos widgets HELPDESK (condicionales) */}
        {isHelpdeskUser && (
          <>
            <HelpdeskSLAWidget />
            <HelpdeskTicketsWidget />
            <HelpdeskChatActivity />
          </>
        )}
        
        {/* Widget de integraciÃ³n */}
        <CasesHelpdeskIntegrationWidget />
        
      </div>
    </PageWrapper>
  );
};
```

**12.5.2 Widget de IntegraciÃ³n**
```typescript
const CasesHelpdeskIntegrationWidget = () => {
  const { data: integrationStats } = useQuery(['integration-stats'], 
    () => integrationService.getStats()
  );
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow">
      <h3 className="text-lg font-semibold mb-4">
        IntegraciÃ³n Casos â†” HELPDESK
      </h3>
      
      <div className="space-y-3">
        <div className="flex justify-between">
          <span>Tickets convertidos a casos:</span>
          <span className="font-bold text-blue-600">
            {integrationStats?.ticketsToCase || 0}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span>Casos con tickets vinculados:</span>
          <span className="font-bold text-green-600">
            {integrationStats?.casesWithTickets || 0}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span>Sincronizaciones hoy:</span>
          <span className="font-bold text-purple-600">
            {integrationStats?.syncToday || 0}
          </span>
        </div>
      </div>
      
      <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-600">
        <Link 
          to="/helpdesk/integration-report" 
          className="text-sm text-blue-600 hover:text-blue-800"
        >
          Ver reporte completo â†’
        </Link>
      </div>
    </div>
  );
};
```

12.6 Ventajas de la IntegraciÃ³n

**12.6.1 Beneficios TÃ©cnicos**
- âœ… **ReutilizaciÃ³n de CÃ³digo**: 70% de componentes base reutilizados
- âœ… **Consistencia UI/UX**: Misma experiencia visual y de navegaciÃ³n
- âœ… **Base de Datos Unificada**: Sin duplicaciÃ³n de datos de usuarios
- âœ… **Seguridad Cohesiva**: PolÃ­ticas RLS y permisos centralizados
- âœ… **Realtime Compartido**: Misma infraestructura de WebSockets

**12.6.2 Beneficios Operacionales**
- âœ… **Flujo Ãšnico**: TransiciÃ³n natural de tickets a casos complejos
- âœ… **Historial Completo**: Trazabilidad total de la interacciÃ³n cliente
- âœ… **Equipos Especializados**: Cada nivel maneja su especialidad
- âœ… **MÃ©tricas Integradas**: VisiÃ³n completa del pipeline de soporte
- âœ… **EscalaciÃ³n Inteligente**: Basada en complejidad real del problema

**12.6.3 Beneficios para el Usuario**
- âœ… **Experiencia Unificada**: Una sola aplicaciÃ³n, mÃºltiples funcionalidades
- âœ… **Datos Sincronizados**: InformaciÃ³n coherente en todos los mÃ³dulos
- âœ… **Flujos Optimizados**: Menos clicks, mÃ¡s productividad
- âœ… **Aprendizaje MÃ­nimo**: Interfaz familiar para usuarios existentes

12.7 Plan de MigraciÃ³n

**12.7.1 Estrategia de AdopciÃ³n Gradual**
```
Fase 1: PreparaciÃ³n (Semana 1-2)
â”œâ”€â”€ Backup completo de base de datos actual
â”œâ”€â”€ MigraciÃ³n de roles y permisos
â”œâ”€â”€ Testing de compatibilidad
â””â”€â”€ CapacitaciÃ³n inicial del equipo

Fase 2: Piloto Controlado (Semana 3-4)
â”œâ”€â”€ ActivaciÃ³n para 10% de usuarios (power users)
â”œâ”€â”€ Monitoreo intensivo de performance
â”œâ”€â”€ RecolecciÃ³n de feedback inicial
â””â”€â”€ Ajustes basados en uso real

Fase 3: Rollout Gradual (Semana 5-8)
â”œâ”€â”€ ExpansiÃ³n a 50% de usuarios
â”œâ”€â”€ ActivaciÃ³n de integraciones con casos
â”œâ”€â”€ Training completo para todos los agentes
â””â”€â”€ OptimizaciÃ³n de flujos identificados

Fase 4: AdopciÃ³n Completa (Semana 9-10)
â”œâ”€â”€ MigraciÃ³n del 100% de usuarios
â”œâ”€â”€ ActivaciÃ³n de todas las funcionalidades
â”œâ”€â”€ Monitoreo post-implementaciÃ³n
â””â”€â”€ DocumentaciÃ³n de lecciones aprendidas
```

---

*Este documento tÃ©cnico establece las bases para la implementaciÃ³n exitosa del mÃ³dulo HELPDESK, asegurando que el proyecto cumpla con los mÃ¡s altos estÃ¡ndares de calidad tÃ©cnica y experiencia de usuario, mientras mantiene perfecta integraciÃ³n con el sistema existente.*

**Documento generado el 28 de Julio, 2025**
**VersiÃ³n 1.0 - EspecificaciÃ³n TÃ©cnica Completa**