
📋 DOCUMENTO TÉCNICO: MÓDULO HELPDESK

═══════════════════════════════════════════════════════════════════

📑 INFORMACIÓN DEL DOCUMENTO

| Campo          | Valor                                           |
|---------------|-------------------------------------------------|
| **Documento** | Especificación Técnica - Módulo HELPDESK      |
| **Versión**   | 1.0                                            |
| **Fecha**     | 28 de Julio, 2025                              |
| **Autor**     | GitHub Copilot                                 |
| **Proyecto**  | Sistema de Gestión de Casos - case-management-react |
| **Estado**    | Especificación - No Implementado               |
| **Revisor**   | Equipo de Desarrollo                           |
| **Aprobación**| Pendiente                                      |

═══════════════════════════════════════════════════════════════════

🎯 1. RESUMEN EJECUTIVO

1.1 Propósito

El módulo HELPDESK representa una evolución estratégica del sistema de gestión de casos existente, introduciendo un sistema de tickets con chat en tiempo real que servirá como **punto de entrada unificado** para todas las solicitudes de soporte y servicios. Este módulo transformará fundamentalmente el flujo operativo actual, convirtiendo el módulo "Nuevo Caso" en un **clasificador especializado** que procesa y categoriza los tickets del HELPDESK.

**Objetivos Estratégicos:**
- **Centralización de Solicitudes**: Unificar todos los canales de comunicación en una sola plataforma
- **Mejora en SLA**: Implementar controles rigurosos de tiempo de respuesta y resolución
- **Automatización Inteligente**: Reducir intervención manual mediante algoritmos de asignación y escalación
- **Visibilidad Operacional**: Proporcionar métricas en tiempo real para la toma de decisiones

1.2 Alcance del Proyecto

**✅ INCLUIDO EN EL ALCANCE:**

**Módulo de Tickets:**
- Sistema completo de tickets con numeración automática (HD-YYYY-NNNNNN)
- Chat en tiempo real con soporte multi-usuario
- Gestión de estados del ciclo de vida completo
- Sistema de prioridades y categorización
- Tracking de SLA con alertas automáticas

**Dashboard Especializado:**
- Métricas de SLA y ANS en tiempo real
- Widgets personalizables por rol
- Reportes de performance de agentes
- Análisis de tendencias y patrones
- Alertas de incumplimiento de SLA

**Sistema de Roles y Permisos:**
- 8 nuevos roles especializados (Customer, Agent L1-L3, Supervisor, Team Lead, Manager, Escalation Analyst)
- 25+ permisos granulares específicos para HELPDESK
- Row Level Security (RLS) implementado en PostgreSQL
- Matriz de permisos configurable

**Integración con Módulos Existentes:**
- Sincronización bidireccional con módulo de Casos
- Integración con sistema de TODOs
- Aprovechamiento de infraestructura de usuarios y roles actual
- API de integración para sistemas externos

**Automatización y IA:**
- Motor de auto-asignación configurable
- Sistema de escalación automática
- Cálculo dinámico de SLA
- Análisis de patrones de tickets

**✅ FUNCIONALIDADES PRINCIPALES:**

1. **Chat en Tiempo Real**
   - Mensajes instantáneos con WebSockets
   - Soporte para archivos adjuntos (hasta 10MB)
   - Indicadores de escritura y estado de mensajes
   - Notas internas solo para agentes
   - Historial completo de conversaciones

2. **Gestión de SLA**
   - Configuración flexible por prioridad y categoría
   - Tracking automático de tiempo de primera respuesta
   - Monitoreo de tiempo de resolución
   - Alertas preventivas antes de incumplimiento
   - Reportes de cumplimiento detallados

3. **Sistema de Escalación**
   - Reglas configurables de escalación automática
   - Escalación manual entre niveles
   - Notificaciones automáticas a supervisores
   - Tracking de cadena de escalación
   - Análisis de causas de escalación

4. **Dashboard y Reportes**
   - Vista en tiempo real de métricas clave
   - Filtros avanzados por período, agente, categoría
   - Exportación de reportes en múltiples formatos
   - Análisis de satisfacción del cliente
   - Trending de volumen y performance

5. **Integración Inteligente**
   - Conversión automática de tickets a casos
   - Clasificación de complejidad asistida por IA
   - Sincronización de estados cross-módulo
   - API REST completa para integraciones

**❌ EXCLUIDO DEL ALCANCE:**

- Integración con sistemas telefónicos (PBX)
- Chatbots con AI conversacional avanzada
- Integración con WhatsApp Business (fase futura)
- Sistema de facturación integrado
- Módulo de knowledge base completo (solo básico)
- Integración con herramientas de monitoreo externas

**🎯 BENEFICIOS ESPERADOS:**

**Para el Negocio:**
- **↗️ +40% mejora** en tiempo de primera respuesta
- **↗️ +35% aumento** en satisfacción del cliente
- **↘️ -50% reducción** en tickets escalados por SLA
- **↗️ +60% incremento** en visibilidad operacional

**Para los Agentes:**
- **↘️ -30% reducción** en tiempo de clasificación de casos
- **↗️ +45% mejora** en eficiencia de asignación
- **↗️ +25% incremento** en productividad por automatización
- **↗️ +80% mejora** en acceso a información contextual

**Para los Clientes:**
- **↗️ +90% mejora** en tiempo de respuesta inicial
- **↗️ +70% incremento** en transparencia del proceso
- **↗️ +60% mejora** en experiencia general
- **↘️ -40% reducción** en seguimientos innecesarios

1.3 Objetivos Técnicos

**Objetivos de Performance:**
- Tiempo de respuesta del chat < 100ms
- Disponibilidad del sistema > 99.5%
- Soporte para 100+ usuarios concurrentes
- Capacidad de procesamiento de 1000+ tickets/día

**Objetivos de Escalabilidad:**
- Arquitectura modular que permita crecimiento horizontal
- Base de datos optimizada para millones de tickets
- Sistema de caché para métricas en tiempo real
- API rate limiting para prevenir abuso

**Objetivos de Mantenibilidad:**
- Cobertura de pruebas > 85%
- Documentación técnica completa
- Logs estructurados para debugging
- Monitoreo proactivo de salud del sistema

═══════════════════════════════════════════════════════════════════

🏗️ 2. ARQUITECTURA DEL SISTEMA

2.1 Arquitectura General

```
┌─────────────────────────────────────────────────────────────┐
│                    FRONTEND (React + TypeScript)            │
├─────────────────────────────────────────────────────────────┤
│  📱 Chat Interface  │  📊 Dashboard  │  🎛️ Admin Panel    │
│  🎫 Ticket List     │  📈 Reports    │  ⚙️ Configuration  │
├─────────────────────────────────────────────────────────────┤
│                    ESTADO GLOBAL (Zustand)                  │
├─────────────────────────────────────────────────────────────┤
│                    CAPA DE SERVICIOS                        │
│  🔄 SLA Service  │  📨 Chat Service  │  🚨 Escalation     │
├─────────────────────────────────────────────────────────────┤
│                    SUPABASE (Backend as a Service)          │
│  🗄️ PostgreSQL   │  🔐 Auth        │  📡 Realtime       │
│  📎 Storage      │  🛡️ RLS         │  🔌 API            │
└─────────────────────────────────────────────────────────────┘
```

2.2 Patrones de Arquitectura Utilizados

- **MVC (Model-View-Controller)**: Separación clara entre datos, vista y lógica
- **Pub/Sub**: Para comunicación en tiempo real via Supabase Realtime
- **Repository Pattern**: Para abstracción de acceso a datos
- **Observer Pattern**: Para actualizaciones reactivas de estado
- **Strategy Pattern**: Para diferentes algoritmos de asignación y escalación

═══════════════════════════════════════════════════════════════════

🗄️ 3. DISEÑO DE BASE DE DATOS

3.1 Diagrama ERD

```
helpdesk_tickets  ←→  helpdesk_chat_messages
       ↓
helpdesk_sla_tracking
       ↓
helpdesk_escalations
       ↓
helpdesk_case_link  ←→  cases (módulo existente)
```

3.2 Tablas Principales

3.2.1 helpdesk_tickets
```sql
CREATE TABLE helpdesk_tickets (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_number VARCHAR(20) UNIQUE NOT NULL, -- HD-2025-001
    subject VARCHAR(255) NOT NULL,
    description TEXT,
    priority_id UUID REFERENCES helpdesk_priorities(id),
    category_id UUID REFERENCES helpdesk_categories(id),
    status_id UUID REFERENCES helpdesk_statuses(id),
    requester_user_id UUID REFERENCES user_profiles(id),
    assigned_agent_id UUID REFERENCES user_profiles(id),
    escalated_to_user_id UUID REFERENCES user_profiles(id),
    channel_id UUID REFERENCES helpdesk_channels(id),
    source_type VARCHAR(50) DEFAULT 'chat',
    severity_level INTEGER DEFAULT 3 CHECK (severity_level BETWEEN 1 AND 5),
    impact_level INTEGER DEFAULT 3 CHECK (impact_level BETWEEN 1 AND 5),
    urgency_level INTEGER DEFAULT 3 CHECK (urgency_level BETWEEN 1 AND 5),
    sla_due_date TIMESTAMP,
    first_response_at TIMESTAMP,
    resolution_date TIMESTAMP,
    satisfaction_rating INTEGER CHECK (satisfaction_rating BETWEEN 1 AND 5),
    satisfaction_comment TEXT,
    tags JSONB DEFAULT '[]',
    custom_fields JSONB DEFAULT '{}',
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now(),
    closed_at TIMESTAMP
);

-- Índices para optimización
CREATE INDEX idx_helpdesk_tickets_status ON helpdesk_tickets(status_id);
CREATE INDEX idx_helpdesk_tickets_assigned ON helpdesk_tickets(assigned_agent_id);
CREATE INDEX idx_helpdesk_tickets_requester ON helpdesk_tickets(requester_user_id);
CREATE INDEX idx_helpdesk_tickets_sla_due ON helpdesk_tickets(sla_due_date);
CREATE INDEX idx_helpdesk_tickets_created ON helpdesk_tickets(created_at);
```

3.2.2 helpdesk_chat_messages
```sql
CREATE TABLE helpdesk_chat_messages (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID REFERENCES helpdesk_tickets(id) ON DELETE CASCADE,
    sender_user_id UUID REFERENCES user_profiles(id),
    message_type VARCHAR(50) DEFAULT 'text' CHECK (message_type IN ('text', 'image', 'file', 'system')),
    content TEXT NOT NULL,
    attachments JSONB DEFAULT '[]',
    is_internal BOOLEAN DEFAULT false,
    is_system_message BOOLEAN DEFAULT false,
    edited_at TIMESTAMP,
    created_at TIMESTAMP DEFAULT now()
);

-- Índices
CREATE INDEX idx_chat_messages_ticket ON helpdesk_chat_messages(ticket_id, created_at);
CREATE INDEX idx_chat_messages_sender ON helpdesk_chat_messages(sender_user_id);
```

3.2.3 helpdesk_sla_tracking
```sql
CREATE TABLE helpdesk_sla_tracking (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    ticket_id UUID REFERENCES helpdesk_tickets(id) ON DELETE CASCADE,
    sla_type VARCHAR(50) NOT NULL CHECK (sla_type IN ('first_response', 'resolution')),
    target_date TIMESTAMP NOT NULL,
    achieved_date TIMESTAMP,
    is_breached BOOLEAN DEFAULT false,
    breach_time_minutes INTEGER DEFAULT 0,
    escalation_triggered BOOLEAN DEFAULT false,
    created_at TIMESTAMP DEFAULT now(),
    updated_at TIMESTAMP DEFAULT now()
);
```

3.3 Funciones y Triggers

3.3.1 Función para generar número de ticket
```sql
CREATE OR REPLACE FUNCTION generate_ticket_number()
RETURNS TEXT AS $$
DECLARE
    year_part TEXT;
    sequence_part TEXT;
    result TEXT;
BEGIN
    year_part := EXTRACT(YEAR FROM NOW())::TEXT;
    
    SELECT LPAD((COUNT(*) + 1)::TEXT, 6, '0') INTO sequence_part
    FROM helpdesk_tickets 
    WHERE EXTRACT(YEAR FROM created_at) = EXTRACT(YEAR FROM NOW());
    
    result := 'HD-' || year_part || '-' || sequence_part;
    
    RETURN result;
END;
$$ LANGUAGE plpgsql;
```

3.3.2 Trigger para auto-generar número de ticket
```sql
CREATE OR REPLACE FUNCTION set_ticket_number()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.ticket_number IS NULL THEN
        NEW.ticket_number := generate_ticket_number();
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_set_ticket_number
    BEFORE INSERT ON helpdesk_tickets
    FOR EACH ROW EXECUTE FUNCTION set_ticket_number();
```

3.3.3 Función para calcular SLA
```sql
CREATE OR REPLACE FUNCTION calculate_sla_dates(
    p_priority_id UUID,
    p_category_id UUID,
    p_created_at TIMESTAMP DEFAULT NOW()
)
RETURNS TABLE(
    first_response_due TIMESTAMP,
    resolution_due TIMESTAMP
) AS $$
DECLARE
    priority_response_hours INTEGER;
    priority_resolution_hours INTEGER;
    category_modifier DECIMAL(5,2);
BEGIN
    -- Obtener tiempos SLA de la prioridad
    SELECT 
        hp.sla_response_hours,
        hp.sla_resolution_hours
    INTO priority_response_hours, priority_resolution_hours
    FROM helpdesk_priorities hp
    WHERE hp.id = p_priority_id;
    
    -- Obtener modificador de categoría
    SELECT COALESCE(hc.sla_modifier_percentage, 100.00) / 100.0
    INTO category_modifier
    FROM helpdesk_categories hc
    WHERE hc.id = p_category_id;
    
    -- Calcular fechas SLA
    first_response_due := p_created_at + 
        INTERVAL '1 hour' * (priority_response_hours * category_modifier);
    
    resolution_due := p_created_at + 
        INTERVAL '1 hour' * (priority_resolution_hours * category_modifier);
    
    RETURN NEXT;
END;
$$ LANGUAGE plpgsql;
```

═══════════════════════════════════════════════════════════════════

🎨 4. DISEÑO DE INTERFAZ DE USUARIO

4.1 Componentes Principales

4.1.1 Chat Interface
```typescript
interface ChatInterfaceProps {
    ticketId: string;
    currentUser: User;
    onSendMessage: (message: string, attachments?: File[]) => void;
    onTyping: (isTyping: boolean) => void;
}

interface ChatInterfaceState {
    messages: ChatMessage[];
    isTyping: boolean;
    typingUsers: User[];
    showInternalNotes: boolean;
    attachmentPreview?: File;
}
```

Características técnicas:
- **WebSocket Connection**: Supabase Realtime para mensajes en tiempo real
- **Typing Indicators**: Indicadores de escritura
- **Message Status**: Estados de mensaje (enviado, entregado, leído)
- **File Upload**: Soporte para archivos hasta 10MB
- **Emoji Support**: Picker de emojis integrado
- **Message Threading**: Respuestas anidadas
- **Auto-scroll**: Scroll automático a nuevos mensajes

4.1.2 Ticket List Component
```typescript
interface TicketListProps {
    filters: TicketFilters;
    sortBy: TicketSortField;
    groupBy?: TicketGroupField;
    viewMode: 'list' | 'grid' | 'kanban';
    onTicketSelect: (ticket: HelpdeskTicket) => void;
}

interface TicketFilters {
    status: string[];
    priority: string[];
    assignedTo: string[];
    category: string[];
    searchTerm: string;
    dateRange: DateRange;
    slaStatus: 'compliant' | 'at_risk' | 'breached';
}
```

Vista Kanban por estados:
```
┌─────────────┬─────────────┬─────────────┬─────────────┐
│    NEW      │    OPEN     │  PENDING    │   RESOLVED  │
├─────────────┼─────────────┼─────────────┼─────────────┤
│ [Ticket 1]  │ [Ticket 3]  │ [Ticket 5]  │ [Ticket 7]  │
│ [Ticket 2]  │ [Ticket 4]  │ [Ticket 6]  │ [Ticket 8]  │
└─────────────┴─────────────┴─────────────┴─────────────┘
```

4.1.3 Dashboard Widgets

SLA Compliance Widget:
```typescript
interface SLAComplianceWidget {
    data: {
        firstResponse: {
            target: number;    // 95%
            actual: number;    // 92%
            trend: number;     // +2%
        };
        resolution: {
            target: number;    // 90%
            actual: number;    // 88%
            trend: number;     // -1%
        };
    };
    timeframe: 'today' | 'week' | 'month';
}
```

4.2 Layouts Responsive

4.2.1 Desktop Layout (>1024px)
```
┌─────────────────────────────────────────────────────────────┐
│                      Top Navigation                         │
├───────────┬─────────────────────────┬───────────────────────┤
│           │                         │                       │
│  Sidebar  │       Main Content      │    Right Panel       │
│  (256px)  │       (flexible)        │      (320px)         │
│           │                         │                       │
│  - Filters│  ┌─────────────────────┐ │  ┌─────────────────┐ │
│  - Quick  │  │                     │ │  │                 │ │
│    Actions│  │   Ticket List/Chat  │ │  │  Ticket Details │ │
│  - Stats  │  │                     │ │  │                 │ │
│           │  └─────────────────────┘ │  └─────────────────┘ │
└───────────┴─────────────────────────┴───────────────────────┘
```

4.2.2 Mobile Layout (<768px)
```
┌─────────────────────────────────────┐
│           Top Bar + Menu            │
├─────────────────────────────────────┤
│                                     │
│           Main Content              │
│          (full width)               │
│                                     │
│  ┌─────────────────────────────────┐│
│  │                                 ││
│  │        Ticket List/Chat         ││
│  │                                 ││
│  └─────────────────────────────────┘│
├─────────────────────────────────────┤
│          Bottom Navigation          │
└─────────────────────────────────────┘
```

4.3 Design System

4.3.1 Colores del Tema
```typescript
const helpdeskTheme = {
    colors: {
        // Estados de SLA
        sla: {
            compliant: '#10B981',    // Verde
            atRisk: '#F59E0B',       // Amarillo
            breached: '#EF4444',     // Rojo
        },
        
        // Prioridades
        priority: {
            critical: '#DC2626',     // Rojo intenso
            high: '#EA580C',         // Naranja
            medium: '#D97706',       // Amarillo oscuro
            low: '#059669',          // Verde
            veryLow: '#6B7280',      // Gris
        },
        
        // Estados de tickets
        status: {
            new: '#3B82F6',          // Azul
            open: '#8B5CF6',         // Púrpura
            pending: '#F59E0B',      // Amarillo
            resolved: '#10B981',     // Verde
            closed: '#6B7280',       // Gris
        },
        
        // Chat
        chat: {
            userMessage: '#3B82F6',  // Azul
            agentMessage: '#6B7280', // Gris
            systemMessage: '#F59E0B', // Amarillo
            internalNote: '#EF4444', // Rojo
        }
    }
};
```

4.3.2 Tipografía
```css
/* Jerarquía tipográfica para HELPDESK */
.helpdesk-title {
    @apply text-2xl font-bold text-gray-900 dark:text-white;
}

.helpdesk-subtitle {
    @apply text-lg font-semibold text-gray-700 dark:text-gray-300;
}

.helpdesk-body {
    @apply text-sm text-gray-600 dark:text-gray-400;
}

.helpdesk-caption {
    @apply text-xs text-gray-500 dark:text-gray-500;
}

.helpdesk-badge {
    @apply inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium;
}
```

═══════════════════════════════════════════════════════════════════

⚙️ 5. LÓGICA DE NEGOCIO

5.1 Flujo de Estados de Tickets

```typescript
enum TicketStatus {
    NEW = 'new',
    OPEN = 'open',
    PENDING_CUSTOMER = 'pending_customer',
    PENDING_VENDOR = 'pending_vendor',
    ESCALATED_L2 = 'escalated_l2',
    ESCALATED_L3 = 'escalated_l3',
    ESCALATED_MANAGEMENT = 'escalated_management',
    RESOLVED = 'resolved',
    CLOSED = 'closed',
    ON_HOLD = 'on_hold',
    CLASSIFIED_TO_CASE = 'classified_to_case',
    CANCELLED = 'cancelled'
}

// Transiciones válidas
const VALID_TRANSITIONS = {
    [TicketStatus.NEW]: [TicketStatus.OPEN, TicketStatus.ESCALATED_L2],
    [TicketStatus.OPEN]: [
        TicketStatus.PENDING_CUSTOMER, 
        TicketStatus.ESCALATED_L2, 
        TicketStatus.RESOLVED,
        TicketStatus.CLASSIFIED_TO_CASE,
        TicketStatus.ON_HOLD
    ],
    [TicketStatus.PENDING_CUSTOMER]: [TicketStatus.OPEN, TicketStatus.ESCALATED_L2],
    [TicketStatus.ESCALATED_L2]: [TicketStatus.ESCALATED_L3, TicketStatus.RESOLVED],
    [TicketStatus.RESOLVED]: [TicketStatus.CLOSED, TicketStatus.OPEN],
    // ... resto de transiciones
};
```

5.2 Algoritmo de Auto-asignación

```typescript
interface AutoAssignmentRule {
    priority: number;
    condition: AssignmentCondition;
    action: AssignmentAction;
}

interface AssignmentCondition {
    category?: string[];
    priority?: string[];
    timeOfDay?: TimeRange;
    customerVIP?: boolean;
    keywords?: string[];
}

interface AssignmentAction {
    assignTo?: 'agent' | 'team' | 'specific_user';
    agentId?: string;
    teamId?: string;
    escalationDelay?: number; // minutos
}

class AutoAssignmentEngine {
    async assignTicket(ticket: HelpdeskTicket): Promise<string | null> {
        const rules = await this.getAssignmentRules();
        
        for (const rule of rules.sort((a, b) => a.priority - b.priority)) {
            if (this.evaluateCondition(ticket, rule.condition)) {
                return this.executeAction(ticket, rule.action);
            }
        }
        
        // Fallback: asignar al agente menos ocupado
        return this.assignToLeastBusyAgent();
    }
    
    private evaluateCondition(ticket: HelpdeskTicket, condition: AssignmentCondition): boolean {
        if (condition.category && !condition.category.includes(ticket.category.id)) {
            return false;
        }
        
        if (condition.priority && !condition.priority.includes(ticket.priority.id)) {
            return false;
        }
        
        if (condition.timeOfDay && !this.isWithinTimeRange(condition.timeOfDay)) {
            return false;
        }
        
        if (condition.customerVIP && !ticket.requester.isVIP) {
            return false;
        }
        
        if (condition.keywords && !this.containsKeywords(ticket, condition.keywords)) {
            return false;
        }
        
        return true;
    }
}
```

5.3 Sistema de Escalación

```typescript
interface EscalationRule {
    id: string;
    name: string;
    trigger: EscalationTrigger;
    action: EscalationAction;
    isActive: boolean;
}

interface EscalationTrigger {
    type: 'time_based' | 'sla_breach' | 'manual' | 'priority_based';
    conditions: {
        timeThresholdMinutes?: number;
        slaType?: 'first_response' | 'resolution';
        priorityLevel?: number;
        statusCriteria?: string[];
    };
}

interface EscalationAction {
    escalateTo: 'agent' | 'team' | 'management';
    targetId?: string;
    notifyUsers: string[];
    updatePriority?: boolean;
    addTags?: string[];
    createFollowUpTask?: boolean;
}

class EscalationEngine {
    async processEscalations(): Promise<void> {
        const ticketsToEvaluate = await this.getTicketsForEscalation();
        const rules = await this.getActiveEscalationRules();
        
        for (const ticket of ticketsToEvaluate) {
            for (const rule of rules) {
                if (await this.shouldEscalate(ticket, rule)) {
                    await this.executeEscalation(ticket, rule);
                }
            }
        }
    }
    
    private async shouldEscalate(ticket: HelpdeskTicket, rule: EscalationRule): Promise<boolean> {
        switch (rule.trigger.type) {
            case 'time_based':
                return this.checkTimeBasedEscalation(ticket, rule.trigger.conditions);
            case 'sla_breach':
                return this.checkSLABreachEscalation(ticket, rule.trigger.conditions);
            case 'priority_based':
                return this.checkPriorityBasedEscalation(ticket, rule.trigger.conditions);
            default:
                return false;
        }
    }
}
```

5.4 Cálculo de SLA

```typescript
interface SLACalculator {
    calculateFirstResponseSLA(ticket: HelpdeskTicket): SLAResult;
    calculateResolutionSLA(ticket: HelpdeskTicket): SLAResult;
    updateSLATracking(ticketId: string, event: SLAEvent): Promise<void>;
}

interface SLAResult {
    targetDate: Date;
    currentStatus: 'compliant' | 'at_risk' | 'breached';
    timeRemaining: number; // minutos
    breachTime?: number; // minutos después del objetivo
}

class SLAService implements SLACalculator {
    calculateFirstResponseSLA(ticket: HelpdeskTicket): SLAResult {
        const baseMinutes = ticket.priority.slaResponseHours * 60;
        const modifier = ticket.category.slaModifierPercentage / 100;
        const adjustedMinutes = baseMinutes * modifier;
        
        const targetDate = new Date(ticket.createdAt.getTime() + adjustedMinutes * 60000);
        const now = new Date();
        const timeRemaining = Math.max(0, targetDate.getTime() - now.getTime()) / 60000;
        
        let currentStatus: 'compliant' | 'at_risk' | 'breached';
        if (ticket.firstResponseAt) {
            currentStatus = ticket.firstResponseAt <= targetDate ? 'compliant' : 'breached';
        } else if (timeRemaining <= adjustedMinutes * 0.2) { // 20% del tiempo restante
            currentStatus = 'at_risk';
        } else {
            currentStatus = 'compliant';
        }
        
        return {
            targetDate,
            currentStatus,
            timeRemaining,
            breachTime: currentStatus === 'breached' ? (now.getTime() - targetDate.getTime()) / 60000 : undefined
        };
    }
    
    async updateSLATracking(ticketId: string, event: SLAEvent): Promise<void> {
        const tracking = await this.getSLATracking(ticketId);
        
        switch (event.type) {
            case 'first_response':
                await this.updateFirstResponseSLA(tracking, event.timestamp);
                break;
            case 'resolution':
                await this.updateResolutionSLA(tracking, event.timestamp);
                break;
            case 'status_change':
                await this.handleStatusChangeSLA(tracking, event);
                break;
        }
    }
}
```

═══════════════════════════════════════════════════════════════════

🔐 6. SEGURIDAD Y PERMISOS

6.1 Row Level Security (RLS)

6.1.1 Políticas para helpdesk_tickets
```sql
-- Política para customers: solo ven sus propios tickets
CREATE POLICY "customers_own_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') = 'helpdesk_customer' 
        AND requester_user_id = auth.uid()
    );

-- Política para agentes: ven tickets asignados y de su equipo
CREATE POLICY "agents_assigned_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_agent_l1', 'helpdesk_agent_l2', 'helpdesk_agent_l3')
        AND (
            assigned_agent_id = auth.uid()
            OR assigned_agent_id IN (
                SELECT tm.user_id 
                FROM team_members tm 
                WHERE tm.team_id IN (
                    SELECT tm2.team_id 
                    FROM team_members tm2 
                    WHERE tm2.user_id = auth.uid()
                )
            )
        )
    );

-- Política para supervisores: ven todos los tickets de sus equipos
CREATE POLICY "supervisors_team_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_supervisor', 'helpdesk_team_lead')
        AND assigned_agent_id IN (
            SELECT tm.user_id 
            FROM team_members tm 
            INNER JOIN teams t ON tm.team_id = t.id
            WHERE t.team_lead_id = auth.uid()
        )
    );

-- Política para managers: ven todos los tickets
CREATE POLICY "managers_all_tickets" ON helpdesk_tickets
    FOR ALL USING (
        (auth.jwt() ->> 'role') IN ('helpdesk_manager', 'admin')
    );
```

6.1.2 Políticas para helpdesk_chat_messages
```sql
-- Los usuarios pueden ver mensajes de tickets a los que tienen acceso
CREATE POLICY "users_ticket_messages" ON helpdesk_chat_messages
    FOR SELECT USING (
        ticket_id IN (
            SELECT id FROM helpdesk_tickets
            -- Reutiliza las políticas de tickets
        )
    );

-- Solo agentes pueden ver mensajes internos
CREATE POLICY "agents_internal_messages" ON helpdesk_chat_messages
    FOR SELECT USING (
        NOT is_internal 
        OR (auth.jwt() ->> 'role') NOT LIKE 'helpdesk_customer%'
    );

-- Los usuarios pueden insertar mensajes en tickets accesibles
CREATE POLICY "users_send_messages" ON helpdesk_chat_messages
    FOR INSERT WITH CHECK (
        ticket_id IN (
            SELECT id FROM helpdesk_tickets
            -- Reutiliza las políticas de tickets
        )
        AND sender_user_id = auth.uid()
    );
```

6.2 Funciones de Autorización

```sql
-- Función para verificar si un usuario puede acceder a un ticket
CREATE OR REPLACE FUNCTION can_access_ticket(ticket_id UUID, user_id UUID)
RETURNS BOOLEAN AS $$
DECLARE
    user_role TEXT;
    ticket_requester UUID;
    ticket_assigned UUID;
    user_teams UUID[];
    ticket_team UUID;
BEGIN
    -- Obtener rol del usuario
    SELECT role INTO user_role 
    FROM user_profiles 
    WHERE id = user_id;
    
    -- Obtener datos del ticket
    SELECT requester_user_id, assigned_agent_id INTO ticket_requester, ticket_assigned
    FROM helpdesk_tickets 
    WHERE id = ticket_id;
    
    -- Managers y admins pueden ver todo
    IF user_role IN ('helpdesk_manager', 'admin') THEN
        RETURN TRUE;
    END IF;
    
    -- Customers solo ven sus propios tickets
    IF user_role LIKE 'helpdesk_customer%' THEN
        RETURN ticket_requester = user_id;
    END IF;
    
    -- Agentes ven tickets asignados a ellos o a su equipo
    IF user_role LIKE 'helpdesk_agent%' OR user_role LIKE 'helpdesk_supervisor%' THEN
        -- Verificar asignación directa
        IF ticket_assigned = user_id THEN
            RETURN TRUE;
        END IF;
        
        -- Verificar equipo
        SELECT ARRAY_AGG(team_id) INTO user_teams
        FROM team_members 
        WHERE user_id = user_id;
        
        SELECT t.id INTO ticket_team
        FROM teams t
        INNER JOIN team_members tm ON t.id = tm.team_id
        WHERE tm.user_id = ticket_assigned
        LIMIT 1;
        
        RETURN ticket_team = ANY(user_teams);
    END IF;
    
    RETURN FALSE;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

═══════════════════════════════════════════════════════════════════

🔄 7. INTEGRACIÓN CON MÓDULOS EXISTENTES

7.1 Integración con Módulo de Casos

```typescript
interface HelpdeskCaseIntegration {
    // Crear caso desde ticket
    createCaseFromTicket(ticketId: string, classification: CaseClassification): Promise<Case>;
    
    // Vincular ticket existente con caso
    linkTicketToCase(ticketId: string, caseId: string): Promise<void>;
    
    // Sincronizar estados
    syncTicketCaseStatus(ticketId: string, caseId: string): Promise<void>;
    
    // Obtener casos relacionados
    getRelatedCases(ticketId: string): Promise<Case[]>;
}

class HelpdeskCaseService implements HelpdeskCaseIntegration {
    async createCaseFromTicket(ticketId: string, classification: CaseClassification): Promise<Case> {
        const ticket = await this.getTicket(ticketId);
        
        const caseData: CreateCaseData = {
            numeroCaso: await this.generateCaseNumber(),
            descripcion: ticket.description,
            fecha: new Date().toISOString().split('T')[0],
            origenId: await this.getHelpdeskOriginId(),
            aplicacionId: classification.applicationId,
            historialCaso: classification.historialCaso,
            conocimientoModulo: classification.conocimientoModulo,
            manipulacionDatos: classification.manipulacionDatos,
            claridadDescripcion: classification.claridadDescripcion,
            causaFallo: classification.causaFallo,
            userId: ticket.assignedAgentId
        };
        
        // Calcular puntuación y clasificación usando las utilidades existentes
        caseData.puntuacion = calcularPuntuacion(caseData);
        caseData.clasificacion = clasificarCaso(caseData.puntuacion);
        
        const createdCase = await casesService.createCase(caseData);
        
        // Crear vínculo en tabla de integración
        await this.createCaseLink(ticketId, createdCase.id);
        
        // Actualizar estado del ticket
        await this.updateTicketStatus(ticketId, TicketStatus.CLASSIFIED_TO_CASE);
        
        return createdCase;
    }
    
    async syncTicketCaseStatus(ticketId: string, caseId: string): Promise<void> {
        const caseControl = await caseControlService.getCaseControl(caseId);
        
        if (caseControl) {
            const ticket = await this.getTicket(ticketId);
            
            // Mapear estados de caso a estados de ticket
            const statusMapping = {
                'pending': TicketStatus.OPEN,
                'in_progress': TicketStatus.OPEN,
                'on_hold': TicketStatus.ON_HOLD,
                'completed': TicketStatus.RESOLVED,
                'archived': TicketStatus.CLOSED
            };
            
            const newTicketStatus = statusMapping[caseControl.status.name.toLowerCase()];
            
            if (newTicketStatus && ticket.status !== newTicketStatus) {
                await this.updateTicketStatus(ticketId, newTicketStatus);
                
                // Agregar mensaje del sistema
                await this.addSystemMessage(ticketId, 
                    `Estado actualizado automáticamente basado en el caso ${caseControl.case.numeroCaso}: ${caseControl.status.description}`
                );
            }
        }
    }
}
```

7.2 Sincronización de Estados

```typescript
interface StateSyncService {
    // Sincronización bidireccional
    syncTicketToCase(ticketId: string): Promise<void>;
    syncCaseToTicket(caseId: string): Promise<void>;
    
    // Listeners para cambios
    onTicketStatusChange(callback: (ticketId: string, newStatus: string) => void): void;
    onCaseStatusChange(callback: (caseId: string, newStatus: string) => void): void;
}

class StateSynchronizer implements StateSyncService {
    constructor() {
        this.setupRealtimeListeners();
    }
    
    private setupRealtimeListeners(): void {
        // Listener para cambios en tickets
        supabase
            .channel('helpdesk_tickets_changes')
            .on('postgres_changes', 
                { event: 'UPDATE', schema: 'public', table: 'helpdesk_tickets' },
                async (payload) => {
                    const ticketId = payload.new.id;
                    const linkedCases = await this.getLinkedCases(ticketId);
                    
                    for (const caseId of linkedCases) {
                        await this.syncTicketToCase(ticketId);
                    }
                }
            )
            .subscribe();
        
        // Listener para cambios en casos
        supabase
            .channel('case_control_changes')
            .on('postgres_changes',
                { event: 'UPDATE', schema: 'public', table: 'case_control' },
                async (payload) => {
                    const caseId = payload.new.case_id;
                    const linkedTickets = await this.getLinkedTickets(caseId);
                    
                    for (const ticketId of linkedTickets) {
                        await this.syncCaseToTicket(caseId);
                    }
                }
            )
            .subscribe();
    }
}
```

7.3 API de Integración

```typescript
// Endpoints para integración externa
class HelpdeskAPI {
    // Crear ticket desde API externa
    @Post('/api/helpdesk/tickets')
    async createTicket(@Body() ticketData: CreateTicketAPIRequest): Promise<HelpdeskTicket> {
        // Validar API key
        await this.validateAPIKey(ticketData.apiKey);
        
        // Mapear datos de API a formato interno
        const internalTicketData = this.mapAPIToInternal(ticketData);
        
        // Crear ticket
        return await this.helpdeskService.createTicket(internalTicketData);
    }
    
    // Webhook para notificaciones externas
    @Post('/api/helpdesk/webhooks/:eventType')
    async handleWebhook(@Param('eventType') eventType: string, @Body() data: any): Promise<void> {
        switch (eventType) {
            case 'email_received':
                await this.handleEmailToTicket(data);
                break;
            case 'chat_message':
                await this.handleChatMessage(data);
                break;
            case 'external_update':
                await this.handleExternalUpdate(data);
                break;
        }
    }
    
    // Obtener métricas para dashboards externos
    @Get('/api/helpdesk/metrics')
    async getMetrics(@Query() filters: MetricsFilters): Promise<HelpdeskMetrics> {
        return await this.metricsService.getMetrics(filters);
    }
}
```

═══════════════════════════════════════════════════════════════════

═══════════════════════════════════════════════════════════════════

📊 8. MÉTRICAS Y REPORTES

8.1 KPIs Principales

```typescript
interface HelpdeskKPIs {
    // Métricas de SLA
    slaMetrics: {
        firstResponseCompliance: number;      // Porcentaje de cumplimiento primera respuesta
        resolutionCompliance: number;         // Porcentaje de cumplimiento resolución
        averageResponseTime: number;          // Tiempo promedio primera respuesta (minutos)
        averageResolutionTime: number;        // Tiempo promedio resolución (horas)
    };
    
    // Métricas de volumen
    volumeMetrics: {
        totalTickets: number;                 // Total de tickets en período
        newTickets: number;                   // Tickets nuevos
        resolvedTickets: number;              // Tickets resueltos
        escalatedTickets: number;             // Tickets escalados
        reopenedTickets: number;              // Tickets reabiertos
    };
    
    // Métricas de calidad
    qualityMetrics: {
        customerSatisfactionScore: number;    // CSAT promedio (1-5)
        firstCallResolutionRate: number;     // Porcentaje FCR
        escalationRate: number;               // Porcentaje de escalación
        agentUtilizationRate: number;         // Porcentaje utilización agentes
    };
    
    // Métricas de productividad
    productivityMetrics: {
        ticketsPerAgent: number;              // Promedio tickets por agente
        resolutionsByCategory: CategoryStats[]; // Resoluciones por categoría
        peakHoursAnalysis: HourlyStats[];     // Análisis horas pico
        channelEffectiveness: ChannelStats[]; // Efectividad por canal
    };
}
```

8.2 Consultas de Métricas

```sql
-- Vista materializada para métricas de SLA
CREATE MATERIALIZED VIEW helpdesk_sla_metrics AS
SELECT 
    DATE_TRUNC('day', ht.created_at) as metric_date,
    hp.name as priority_name,
    hc.name as category_name,
    COUNT(*) as total_tickets,
    
    -- Métricas de primera respuesta
    COUNT(CASE WHEN ht.first_response_at IS NOT NULL 
               AND ht.first_response_at <= sla.first_response_due 
               THEN 1 END) as first_response_compliant,
    AVG(EXTRACT(EPOCH FROM (ht.first_response_at - ht.created_at))/60) as avg_first_response_minutes,
    
    -- Métricas de resolución
    COUNT(CASE WHEN ht.resolution_date IS NOT NULL 
               AND ht.resolution_date <= sla.resolution_due 
               THEN 1 END) as resolution_compliant,
    AVG(EXTRACT(EPOCH FROM (ht.resolution_date - ht.created_at))/3600) as avg_resolution_hours,
    
    -- Satisfacción del cliente
    AVG(ht.satisfaction_rating) as avg_satisfaction
FROM helpdesk_tickets ht
LEFT JOIN helpdesk_priorities hp ON ht.priority_id = hp.id
LEFT JOIN helpdesk_categories hc ON ht.category_id = hc.id
LEFT JOIN helpdesk_sla_tracking sla ON ht.id = sla.ticket_id
WHERE ht.created_at >= CURRENT_DATE - INTERVAL '30 days'
GROUP BY DATE_TRUNC('day', ht.created_at), hp.name, hc.name;

-- Función para obtener métricas de agente
CREATE OR REPLACE FUNCTION get_agent_metrics(
    p_agent_id UUID,
    p_start_date DATE DEFAULT CURRENT_DATE - INTERVAL '7 days',
    p_end_date DATE DEFAULT CURRENT_DATE
)
RETURNS TABLE(
    total_assigned INTEGER,
    total_resolved INTEGER,
    avg_response_time_minutes NUMERIC,
    avg_resolution_time_hours NUMERIC,
    escalation_rate NUMERIC,
    satisfaction_score NUMERIC
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        COUNT(*)::INTEGER as total_assigned,
        COUNT(CASE WHEN ht.resolution_date IS NOT NULL THEN 1 END)::INTEGER as total_resolved,
        AVG(EXTRACT(EPOCH FROM (ht.first_response_at - ht.created_at))/60) as avg_response_time_minutes,
        AVG(EXTRACT(EPOCH FROM (ht.resolution_date - ht.created_at))/3600) as avg_resolution_time_hours,
        (COUNT(CASE WHEN he.id IS NOT NULL THEN 1 END)::NUMERIC / COUNT(*)::NUMERIC * 100) as escalation_rate,
        AVG(ht.satisfaction_rating) as satisfaction_score
    FROM helpdesk_tickets ht
    LEFT JOIN helpdesk_escalations he ON ht.id = he.ticket_id
    WHERE ht.assigned_agent_id = p_agent_id
    AND ht.created_at::DATE BETWEEN p_start_date AND p_end_date;
END;
$$ LANGUAGE plpgsql;
```

8.3 Dashboard de Métricas

```typescript
interface HelpdeskDashboard {
    // Widget principal de SLA
    slaOverviewWidget: {
        currentPeriod: 'today' | 'week' | 'month';
        targets: {
            firstResponseTarget: number;    // 95%
            resolutionTarget: number;       // 90%
        };
        actual: {
            firstResponseActual: number;
            resolutionActual: number;
        };
        trends: {
            firstResponseTrend: number;     // +2%
            resolutionTrend: number;        // -1%
        };
    };
    
    // Widget de tickets críticos
    criticalTicketsWidget: {
        slaBreached: HelpdeskTicket[];
        aboutToBreach: HelpdeskTicket[];
        unassigned: HelpdeskTicket[];
        highPriority: HelpdeskTicket[];
    };
    
    // Widget de distribución de carga
    workloadWidget: {
        agentDistribution: {
            agentId: string;
            agentName: string;
            activeTickets: number;
            todayResolved: number;
            avgResponseTime: number;
            status: 'available' | 'busy' | 'away';
        }[];
        teamStatistics: {
            teamName: string;
            totalCapacity: number;
            currentLoad: number;
            queueLength: number;
        }[];
    };
    
    // Widget de satisfacción
    satisfactionWidget: {
        currentScore: number;
        trend: number;
        distribution: Record<number, number>; // Rating -> Count
        recentFeedback: {
            ticketNumber: string;
            rating: number;
            comment: string;
            agentName: string;
            date: string;
        }[];
    };
}
```

═══════════════════════════════════════════════════════════════════

🔔 9. SISTEMA DE NOTIFICACIONES

9.1 Arquitectura del Sistema de Notificaciones

El sistema de notificaciones es un componente fundamental que mantiene a todos los usuarios informados sobre eventos críticos en tiempo real, garantizando respuestas rápidas y cumplimiento de SLA.

**9.1.1 Diagrama de Flujo de Notificaciones**
```
┌─────────────────────────────────────────────────────────────────┐
│                    SISTEMA DE NOTIFICACIONES                   │
├─────────────────┬───────────────────────────┬───────────────────┤
│   GENERADORES   │      PROCESAMIENTO        │    ENTREGA        │
│                 │                           │                   │
│ ┌─────────────┐ │ ┌─────────────────────────┐ │ ┌─────────────┐ │
│ │ SLA Events  │─┼►│  Notification Engine    │─┼►│ Web Browser │ │
│ │ Ticket Ops  │ │ │                         │ │ │ Push Notif. │ │
│ │ Chat Msgs   │─┼►│    Priority Queue       │─┼►│ Email       │ │
│ │ Escalations │ │ │                         │ │ │ SMS         │ │
│ │ Case Sync   │─┼►│   Template Engine       │─┼►│ In-App      │ │
│ │ System      │ │ │                         │ │ │ Sound       │ │
│ └─────────────┘ │ └─────────────────────────┘ │ └─────────────┘ │
└─────────────────┴───────────────────────────┴───────────────────┘
                              │
                    ┌─────────▼─────────┐
                    │   PERSISTENCE     │
                    │                   │
                    │ • Notification    │
                    │   History         │
                    │ • User Settings   │
                    │ • Delivery Status │
                    │ • Analytics       │
                    └───────────────────┘
```

**9.1.2 Tipos de Notificaciones**

```typescript
enum NotificationType {
  // Notificaciones de Tickets
  TICKET_CREATED = 'ticket_created',
  TICKET_ASSIGNED = 'ticket_assigned',
  TICKET_STATUS_CHANGED = 'ticket_status_changed',
  TICKET_ESCALATED = 'ticket_escalated',
  TICKET_REOPENED = 'ticket_reopened',
  TICKET_RESOLVED = 'ticket_resolved',
  TICKET_CLOSED = 'ticket_closed',
  
  // Notificaciones de SLA
  SLA_WARNING_15MIN = 'sla_warning_15min',
  SLA_WARNING_5MIN = 'sla_warning_5min',
  SLA_BREACH = 'sla_breach',
  SLA_CRITICAL = 'sla_critical',
  
  // Notificaciones de Chat
  NEW_MESSAGE = 'new_message',
  INTERNAL_MESSAGE = 'internal_message',
  CHAT_TYPING = 'chat_typing',
  
  // Notificaciones de Escalación
  ESCALATION_RECEIVED = 'escalation_received',
  ESCALATION_TIMEOUT = 'escalation_timeout',
  ESCALATION_RESOLVED = 'escalation_resolved',
  
  // Notificaciones de Integración
  TICKET_CONVERTED_TO_CASE = 'ticket_converted_to_case',
  CASE_STATUS_SYNCED = 'case_status_synced',
  CASE_ASSIGNED_FROM_TICKET = 'case_assigned_from_ticket',
  
  // Notificaciones del Sistema
  SYSTEM_MAINTENANCE = 'system_maintenance',
  PERFORMANCE_ALERT = 'performance_alert',
  SECURITY_ALERT = 'security_alert',
  
  // Notificaciones de Satisfacción
  SATISFACTION_SURVEY = 'satisfaction_survey',
  FEEDBACK_RECEIVED = 'feedback_received'
}

enum NotificationPriority {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

enum NotificationCategory {
  TICKET = 'ticket',
  SLA = 'sla',
  CHAT = 'chat',
  ESCALATION = 'escalation',
  INTEGRATION = 'integration',
  SYSTEM = 'system',
  SATISFACTION = 'satisfaction'
}
```

9.2 Modelo de Datos de Notificaciones

**9.2.1 Esquema de Base de Datos**

```sql
-- Tabla principal de notificaciones
CREATE TABLE helpdesk_notifications (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    type VARCHAR(50) NOT NULL,
    title VARCHAR(255) NOT NULL,
    message TEXT,
    priority notification_priority DEFAULT 'medium',
    category notification_category DEFAULT 'system',
    
    -- Información de contexto
    related_entity_id UUID,
    related_entity_type VARCHAR(50),
    metadata JSONB DEFAULT '{}',
    
    -- Estado y seguimiento
    is_read BOOLEAN DEFAULT FALSE,
    requires_action BOOLEAN DEFAULT FALSE,
    action_url TEXT,
    action_label VARCHAR(100),
    
    -- Configuración de entrega
    delivery_channels TEXT[] DEFAULT ARRAY['in_app'],
    delivery_status JSONB DEFAULT '{}',
    
    -- Control de tiempo
    expires_at TIMESTAMP WITH TIME ZONE,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    read_at TIMESTAMP WITH TIME ZONE,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Índices para optimización
    INDEX idx_notifications_user_unread (user_id, is_read, created_at DESC),
    INDEX idx_notifications_type_category (type, category),
    INDEX idx_notifications_priority_created (priority, created_at DESC),
    INDEX idx_notifications_related_entity (related_entity_type, related_entity_id),
    INDEX idx_notifications_expires (expires_at) WHERE expires_at IS NOT NULL
);

-- Tabla de configuración de notificaciones por usuario
CREATE TABLE helpdesk_notification_settings (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    user_id UUID NOT NULL REFERENCES user_profiles(id) ON DELETE CASCADE,
    notification_type VARCHAR(50) NOT NULL,
    
    -- Canales habilitados
    enabled_channels TEXT[] DEFAULT ARRAY['in_app'],
    is_enabled BOOLEAN DEFAULT TRUE,
    
    -- Configuraciones específicas
    quiet_hours_start TIME,
    quiet_hours_end TIME,
    quiet_days INTEGER[] DEFAULT '{}', -- 0=Domingo, 1=Lunes, etc.
    
    -- Agrupación y frecuencia
    batch_enabled BOOLEAN DEFAULT FALSE,
    batch_frequency_minutes INTEGER DEFAULT 15,
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Constraint único por usuario y tipo
    UNIQUE(user_id, notification_type)
);

-- Tabla de plantillas de notificaciones
CREATE TABLE helpdesk_notification_templates (
    id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
    type VARCHAR(50) NOT NULL UNIQUE,
    name VARCHAR(100) NOT NULL,
    
    -- Plantillas por canal
    in_app_title VARCHAR(255),
    in_app_message TEXT,
    email_subject VARCHAR(255),
    email_html TEXT,
    email_text TEXT,
    sms_message VARCHAR(160),
    push_title VARCHAR(100),
    push_message VARCHAR(255),
    
    -- Variables disponibles
    available_variables JSONB DEFAULT '[]',
    
    -- Configuración
    is_active BOOLEAN DEFAULT TRUE,
    priority notification_priority DEFAULT 'medium',
    category notification_category DEFAULT 'system',
    
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Tipos enumerados
CREATE TYPE notification_priority AS ENUM ('low', 'medium', 'high', 'critical');
CREATE TYPE notification_category AS ENUM ('ticket', 'sla', 'chat', 'escalation', 'integration', 'system', 'satisfaction');

-- Políticas RLS
ALTER TABLE helpdesk_notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE helpdesk_notification_settings ENABLE ROW LEVEL SECURITY;

-- Los usuarios solo ven sus propias notificaciones
CREATE POLICY "users_own_notifications" ON helpdesk_notifications
    FOR ALL USING (user_id = auth.uid());

CREATE POLICY "users_own_notification_settings" ON helpdesk_notification_settings
    FOR ALL USING (user_id = auth.uid());

-- Solo administradores pueden gestionar plantillas
CREATE POLICY "admins_manage_templates" ON helpdesk_notification_templates
    FOR ALL USING (
        EXISTS (
            SELECT 1 FROM user_profiles 
            WHERE id = auth.uid() 
            AND role IN ('admin', 'helpdesk_manager')
        )
    );
```

**9.2.2 Interfaces TypeScript**

```typescript
interface HelpdeskNotification {
  id: string;
  userId: string;
  type: NotificationType;
  title: string;
  message: string;
  priority: NotificationPriority;
  category: NotificationCategory;
  
  // Contexto
  relatedEntityId?: string;
  relatedEntityType?: string;
  metadata: Record<string, any>;
  
  // Estado
  isRead: boolean;
  requiresAction: boolean;
  actionUrl?: string;
  actionLabel?: string;
  
  // Entrega
  deliveryChannels: NotificationChannel[];
  deliveryStatus: Record<NotificationChannel, DeliveryStatus>;
  
  // Tiempo
  expiresAt?: Date;
  createdAt: Date;
  readAt?: Date;
  updatedAt: Date;
}

interface NotificationSettings {
  id: string;
  userId: string;
  notificationType: NotificationType;
  enabledChannels: NotificationChannel[];
  isEnabled: boolean;
  quietHoursStart?: string;
  quietHoursEnd?: string;
  quietDays: number[];
  batchEnabled: boolean;
  batchFrequencyMinutes: number;
}

interface NotificationTemplate {
  id: string;
  type: NotificationType;
  name: string;
  inAppTitle?: string;
  inAppMessage?: string;
  emailSubject?: string;
  emailHtml?: string;
  emailText?: string;
  smsMessage?: string;
  pushTitle?: string;
  pushMessage?: string;
  availableVariables: string[];
  isActive: boolean;
  priority: NotificationPriority;
  category: NotificationCategory;
}

enum NotificationChannel {
  IN_APP = 'in_app',
  EMAIL = 'email',
  SMS = 'sms',
  PUSH = 'push',
  SOUND = 'sound'
}

enum DeliveryStatus {
  PENDING = 'pending',
  SENT = 'sent',
  DELIVERED = 'delivered',
  FAILED = 'failed',
  BOUNCED = 'bounced'
}
```

9.3 Motor de Notificaciones

**9.3.1 Servicio Principal**

```typescript
class NotificationEngine {
  private templateEngine: TemplateEngine;
  private deliveryService: DeliveryService;
  private settingsService: NotificationSettingsService;
  
  constructor() {
    this.templateEngine = new TemplateEngine();
    this.deliveryService = new DeliveryService();
    this.settingsService = new NotificationSettingsService();
  }
  
  async createNotification(data: CreateNotificationData): Promise<HelpdeskNotification> {
    // Validar y procesar datos
    const validatedData = this.validateNotificationData(data);
    
    // Obtener configuraciones del usuario
    const userSettings = await this.settingsService.getUserSettings(
      data.userId, 
      data.type
    );
    
    // Verificar si las notificaciones están habilitadas
    if (!userSettings.isEnabled) {
      throw new Error('Notifications disabled for this type');
    }
    
    // Verificar horas silenciosas
    if (this.isInQuietHours(userSettings)) {
      // Programar para después de las horas silenciosas
      await this.scheduleNotification(validatedData, userSettings);
      return;
    }
    
    // Renderizar contenido usando plantillas
    const renderedContent = await this.templateEngine.render(
      data.type,
      data.templateVariables || {}
    );
    
    // Crear notificación en base de datos
    const notification = await this.saveNotification({
      ...validatedData,
      ...renderedContent,
      deliveryChannels: userSettings.enabledChannels
    });
    
    // Entregar notificación
    await this.deliverNotification(notification, userSettings);
    
    return notification;
  }
  
  private async deliverNotification(
    notification: HelpdeskNotification,
    settings: NotificationSettings
  ): Promise<void> {
    const deliveryPromises = settings.enabledChannels.map(channel => 
      this.deliveryService.deliver(notification, channel)
    );
    
    // Ejecutar entregas en paralelo
    const results = await Promise.allSettled(deliveryPromises);
    
    // Actualizar estado de entrega
    const deliveryStatus: Record<NotificationChannel, DeliveryStatus> = {};
    results.forEach((result, index) => {
      const channel = settings.enabledChannels[index];
      deliveryStatus[channel] = result.status === 'fulfilled' 
        ? DeliveryStatus.SENT 
        : DeliveryStatus.FAILED;
    });
    
    // Actualizar en base de datos
    await this.updateDeliveryStatus(notification.id, deliveryStatus);
  }
  
  private isInQuietHours(settings: NotificationSettings): boolean {
    if (!settings.quietHoursStart || !settings.quietHoursEnd) return false;
    
    const now = new Date();
    const currentDay = now.getDay();
    const currentTime = now.toTimeString().slice(0, 5);
    
    // Verificar si hoy es un día silencioso
    if (settings.quietDays.includes(currentDay)) {
      return true;
    }
    
    // Verificar horario silencioso
    const startTime = settings.quietHoursStart;
    const endTime = settings.quietHoursEnd;
    
    if (startTime <= endTime) {
      // Mismo día (ej: 22:00 - 08:00)
      return currentTime >= startTime && currentTime <= endTime;
    } else {
      // Cruza medianoche (ej: 22:00 - 08:00)
      return currentTime >= startTime || currentTime <= endTime;
    }
  }
}

interface CreateNotificationData {
  userId: string;
  type: NotificationType;
  relatedEntityId?: string;
  relatedEntityType?: string;
  templateVariables?: Record<string, any>;
  priority?: NotificationPriority;
  requiresAction?: boolean;
  actionUrl?: string;
  actionLabel?: string;
  expiresAt?: Date;
}
```

**9.3.2 Motor de Plantillas**

```typescript
class TemplateEngine {
  private templates: Map<NotificationType, NotificationTemplate> = new Map();
  
  constructor() {
    this.loadTemplates();
  }
  
  async render(type: NotificationType, variables: Record<string, any>): Promise<RenderedNotification> {
    const template = this.templates.get(type);
    if (!template || !template.isActive) {
      throw new Error(`Template not found or inactive: ${type}`);
    }
    
    return {
      title: this.renderTemplate(template.inAppTitle || '', variables),
      message: this.renderTemplate(template.inAppMessage || '', variables),
      emailSubject: this.renderTemplate(template.emailSubject || '', variables),
      emailHtml: this.renderTemplate(template.emailHtml || '', variables),
      emailText: this.renderTemplate(template.emailText || '', variables),
      smsMessage: this.renderTemplate(template.smsMessage || '', variables),
      pushTitle: this.renderTemplate(template.pushTitle || '', variables),
      pushMessage: this.renderTemplate(template.pushMessage || '', variables),
      priority: template.priority,
      category: template.category
    };
  }
  
  private renderTemplate(template: string, variables: Record<string, any>): string {
    if (!template) return '';
    
    // Reemplazar variables usando sintaxis {{variable}}
    return template.replace(/\{\{(\w+)\}\}/g, (match, varName) => {
      return variables[varName] || match;
    });
  }
  
  private async loadTemplates(): Promise<void> {
    const { data: templates } = await supabase
      .from('helpdesk_notification_templates')
      .select('*')
      .eq('is_active', true);
    
    templates?.forEach(template => {
      this.templates.set(template.type as NotificationType, template);
    });
  }
}

interface RenderedNotification {
  title: string;
  message: string;
  emailSubject: string;
  emailHtml: string;
  emailText: string;
  smsMessage: string;
  pushTitle: string;
  pushMessage: string;
  priority: NotificationPriority;
  category: NotificationCategory;
}
```

**9.3.3 Servicio de Entrega**

```typescript
class DeliveryService {
  async deliver(
    notification: HelpdeskNotification, 
    channel: NotificationChannel
  ): Promise<DeliveryResult> {
    switch (channel) {
      case NotificationChannel.IN_APP:
        return await this.deliverInApp(notification);
      
      case NotificationChannel.EMAIL:
        return await this.deliverEmail(notification);
      
      case NotificationChannel.SMS:
        return await this.deliverSMS(notification);
      
      case NotificationChannel.PUSH:
        return await this.deliverPush(notification);
      
      case NotificationChannel.SOUND:
        return await this.deliverSound(notification);
      
      default:
        throw new Error(`Unsupported delivery channel: ${channel}`);
    }
  }
  
  private async deliverInApp(notification: HelpdeskNotification): Promise<DeliveryResult> {
    // La notificación ya está en la base de datos
    // Enviar vía Supabase Realtime
    await supabase
      .channel('user_notifications')
      .send({
        type: 'broadcast',
        event: 'new_notification',
        payload: {
          userId: notification.userId,
          notification: notification
        }
      });
    
    return { status: DeliveryStatus.SENT, channel: NotificationChannel.IN_APP };
  }
  
  private async deliverEmail(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener email del usuario
      const { data: user } = await supabase
        .from('user_profiles')
        .select('email, full_name')
        .eq('id', notification.userId)
        .single();
      
      if (!user?.email) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.EMAIL,
          error: 'User email not found'
        };
      }
      
      // Configurar y enviar email
      const emailData = {
        to: user.email,
        subject: notification.title,
        html: this.buildEmailHTML(notification, user),
        text: notification.message
      };
      
      // Aquí integrarías con tu proveedor de email (SendGrid, Resend, etc.)
      await this.sendEmail(emailData);
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.EMAIL };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.EMAIL,
        error: error.message 
      };
    }
  }
  
  private async deliverSMS(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener número de teléfono del usuario
      const { data: user } = await supabase
        .from('user_profiles')
        .select('phone_number')
        .eq('id', notification.userId)
        .single();
      
      if (!user?.phone_number) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.SMS,
          error: 'User phone number not found'
        };
      }
      
      // Enviar SMS (integración con Twilio, AWS SNS, etc.)
      await this.sendSMS({
        to: user.phone_number,
        message: `${notification.title}: ${notification.message}`
      });
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.SMS };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.SMS,
        error: error.message 
      };
    }
  }
  
  private async deliverPush(notification: HelpdeskNotification): Promise<DeliveryResult> {
    try {
      // Obtener tokens de push del usuario
      const { data: tokens } = await supabase
        .from('user_push_tokens')
        .select('token, platform')
        .eq('user_id', notification.userId)
        .eq('is_active', true);
      
      if (!tokens || tokens.length === 0) {
        return { 
          status: DeliveryStatus.FAILED, 
          channel: NotificationChannel.PUSH,
          error: 'No active push tokens found'
        };
      }
      
      // Enviar push notifications
      const pushPromises = tokens.map(tokenData => 
        this.sendPushNotification({
          token: tokenData.token,
          title: notification.title,
          body: notification.message,
          data: {
            notificationId: notification.id,
            type: notification.type,
            actionUrl: notification.actionUrl
          }
        })
      );
      
      await Promise.all(pushPromises);
      
      return { status: DeliveryStatus.SENT, channel: NotificationChannel.PUSH };
      
    } catch (error) {
      return { 
        status: DeliveryStatus.FAILED, 
        channel: NotificationChannel.PUSH,
        error: error.message 
      };
    }
  }
  
  private async deliverSound(notification: HelpdeskNotification): Promise<DeliveryResult> {
    // Para notificaciones de sonido, enviamos señal via Realtime
    await supabase
      .channel('user_notifications')
      .send({
        type: 'broadcast',
        event: 'play_notification_sound',
        payload: {
          userId: notification.userId,
          soundType: this.getSoundType(notification.priority),
          repeat: notification.priority === NotificationPriority.CRITICAL ? 3 : 1
        }
      });
    
    return { status: DeliveryStatus.SENT, channel: NotificationChannel.SOUND };
  }
  
  private getSoundType(priority: NotificationPriority): string {
    switch (priority) {
      case NotificationPriority.CRITICAL:
        return 'critical_alert';
      case NotificationPriority.HIGH:
        return 'high_priority';
      case NotificationPriority.MEDIUM:
        return 'standard';
      default:
        return 'low_priority';
    }
  }
}

interface DeliveryResult {
  status: DeliveryStatus;
  channel: NotificationChannel;
  error?: string;
  messageId?: string;
}
```

9.4 Generadores de Notificaciones

**9.4.1 Eventos de Tickets**

```typescript
class TicketNotificationGenerator {
  private notificationEngine: NotificationEngine;
  
  constructor(notificationEngine: NotificationEngine) {
    this.notificationEngine = notificationEngine;
    this.setupEventListeners();
  }
  
  private setupEventListeners(): void {
    // Escuchar cambios en tickets
    supabase
      .channel('ticket_notifications')
      .on('postgres_changes', {
        event: 'INSERT',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, this.handleTicketCreated.bind(this))
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, this.handleTicketUpdated.bind(this))
      .subscribe();
  }
  
  private async handleTicketCreated(payload: any): Promise<void> {
    const ticket = payload.new;
    
    // Notificar al agente asignado (si hay uno)
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: NotificationType.TICKET_ASSIGNED,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: this.mapTicketPriorityToNotificationPriority(ticket.priority_id),
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Ver Ticket',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          customerName: ticket.requester_name,
          priority: ticket.priority_name
        }
      });
    }
    
    // Notificar al supervisor del equipo
    const supervisor = await this.getTeamSupervisor(ticket.assigned_team_id);
    if (supervisor) {
      await this.notificationEngine.createNotification({
        userId: supervisor.id,
        type: NotificationType.TICKET_CREATED,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.MEDIUM,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          customerName: ticket.requester_name,
          assignedAgent: ticket.assigned_agent_name
        }
      });
    }
  }
  
  private async handleTicketUpdated(payload: any): Promise<void> {
    const oldTicket = payload.old;
    const newTicket = payload.new;
    
    // Verificar cambio de asignación
    if (oldTicket.assigned_agent_id !== newTicket.assigned_agent_id) {
      await this.handleTicketReassigned(oldTicket, newTicket);
    }
    
    // Verificar cambio de estado
    if (oldTicket.status_id !== newTicket.status_id) {
      await this.handleTicketStatusChanged(oldTicket, newTicket);
    }
    
    // Verificar escalación
    if (!oldTicket.escalated_to_user_id && newTicket.escalated_to_user_id) {
      await this.handleTicketEscalated(newTicket);
    }
  }
  
  private async handleTicketReassigned(oldTicket: any, newTicket: any): Promise<void> {
    // Notificar al nuevo agente
    if (newTicket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: newTicket.assigned_agent_id,
        type: NotificationType.TICKET_ASSIGNED,
        relatedEntityId: newTicket.id,
        relatedEntityType: 'ticket',
        priority: this.mapTicketPriorityToNotificationPriority(newTicket.priority_id),
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${newTicket.id}`,
        actionLabel: 'Ver Ticket',
        templateVariables: {
          ticketNumber: newTicket.ticket_number,
          ticketSubject: newTicket.subject,
          customerName: newTicket.requester_name,
          previousAgent: oldTicket.assigned_agent_name
        }
      });
    }
    
    // Notificar al agente anterior (si corresponde)
    if (oldTicket.assigned_agent_id && oldTicket.assigned_agent_id !== newTicket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: oldTicket.assigned_agent_id,
        type: NotificationType.TICKET_STATUS_CHANGED,
        relatedEntityId: newTicket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.MEDIUM,
        templateVariables: {
          ticketNumber: newTicket.ticket_number,
          action: 'reasignado',
          newAgent: newTicket.assigned_agent_name
        }
      });
    }
  }
  
  private async handleTicketStatusChanged(oldTicket: any, newTicket: any): Promise<void> {
    const statusMappings = {
      'resolved': { type: NotificationType.TICKET_RESOLVED, priority: NotificationPriority.MEDIUM },
      'closed': { type: NotificationType.TICKET_CLOSED, priority: NotificationPriority.LOW },
      'reopened': { type: NotificationType.TICKET_REOPENED, priority: NotificationPriority.HIGH }
    };
    
    const statusConfig = statusMappings[newTicket.status_name.toLowerCase()];
    if (!statusConfig) return;
    
    // Notificar al cliente
    await this.notificationEngine.createNotification({
      userId: newTicket.requester_user_id,
      type: statusConfig.type,
      relatedEntityId: newTicket.id,
      relatedEntityType: 'ticket',
      priority: statusConfig.priority,
      actionUrl: `/helpdesk/tickets/${newTicket.id}`,
      templateVariables: {
        ticketNumber: newTicket.ticket_number,
        ticketSubject: newTicket.subject,
        newStatus: newTicket.status_name,
        agentName: newTicket.assigned_agent_name
      }
    });
    
    // Si se resolvió, enviar encuesta de satisfacción después de un delay
    if (newTicket.status_name.toLowerCase() === 'resolved') {
      await this.scheduleCustomerSatisfactionSurvey(newTicket);
    }
  }
  
  private async handleTicketEscalated(ticket: any): Promise<void> {
    // Notificar al usuario escalado
    await this.notificationEngine.createNotification({
      userId: ticket.escalated_to_user_id,
      type: NotificationType.ESCALATION_RECEIVED,
      relatedEntityId: ticket.id,
      relatedEntityType: 'ticket',
      priority: NotificationPriority.HIGH,
      requiresAction: true,
      actionUrl: `/helpdesk/tickets/${ticket.id}`,
      actionLabel: 'Revisar Escalación',
      templateVariables: {
        ticketNumber: ticket.ticket_number,
        ticketSubject: ticket.subject,
        escalatedFrom: ticket.assigned_agent_name,
        escalationReason: ticket.escalation_reason
      }
    });
  }
  
  private mapTicketPriorityToNotificationPriority(ticketPriorityId: string): NotificationPriority {
    // Mapear prioridades de ticket a prioridades de notificación
    const priorityMap = {
      '1': NotificationPriority.CRITICAL,
      '2': NotificationPriority.HIGH,
      '3': NotificationPriority.MEDIUM,
      '4': NotificationPriority.LOW,
      '5': NotificationPriority.LOW
    };
    
    return priorityMap[ticketPriorityId] || NotificationPriority.MEDIUM;
  }
}
```

**9.4.2 Eventos de SLA**

```typescript
class SLANotificationGenerator {
  private notificationEngine: NotificationEngine;
  private slaService: SLAService;
  
  constructor(notificationEngine: NotificationEngine, slaService: SLAService) {
    this.notificationEngine = notificationEngine;
    this.slaService = slaService;
    this.startSLAMonitoring();
  }
  
  private startSLAMonitoring(): void {
    // Ejecutar cada minuto para verificar SLA
    setInterval(async () => {
      await this.checkSLABreaches();
    }, 60000); // 1 minuto
  }
  
  private async checkSLABreaches(): Promise<void> {
    // Obtener tickets activos con SLA
    const { data: activeTickets } = await supabase
      .from('helpdesk_tickets')
      .select(`
        id, ticket_number, subject, priority_id, assigned_agent_id,
        requester_user_id, created_at, first_response_at,
        helpdesk_sla_tracking (
          first_response_due, resolution_due, 
          first_response_notified, resolution_notified
        )
      `)
      .in('status_name', ['new', 'open', 'pending', 'in_progress'])
      .not('helpdesk_sla_tracking', 'is', null);
    
    if (!activeTickets) return;
    
    const now = new Date();
    
    for (const ticket of activeTickets) {
      const slaTracking = ticket.helpdesk_sla_tracking[0];
      if (!slaTracking) continue;
      
      // Verificar SLA de primera respuesta
      if (!ticket.first_response_at && !slaTracking.first_response_notified) {
        await this.checkFirstResponseSLA(ticket, slaTracking, now);
      }
      
      // Verificar SLA de resolución
      if (!slaTracking.resolution_notified) {
        await this.checkResolutionSLA(ticket, slaTracking, now);
      }
    }
  }
  
  private async checkFirstResponseSLA(ticket: any, slaTracking: any, now: Date): Promise<void> {
    const dueDate = new Date(slaTracking.first_response_due);
    const timeUntilBreach = dueDate.getTime() - now.getTime();
    const minutesUntilBreach = Math.floor(timeUntilBreach / 60000);
    
    // Alertas a 15 minutos, 5 minutos y cuando se incumple
    if (minutesUntilBreach <= 15 && minutesUntilBreach > 5) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_15MIN, minutesUntilBreach);
      await this.markSLANotified(ticket.id, 'first_response_15min');
    } else if (minutesUntilBreach <= 5 && minutesUntilBreach > 0) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_5MIN, minutesUntilBreach);
      await this.markSLANotified(ticket.id, 'first_response_5min');
    } else if (minutesUntilBreach <= 0) {
      await this.sendSLABreach(ticket, 'first_response');
      await this.markSLANotified(ticket.id, 'first_response_breach');
    }
  }
  
  private async checkResolutionSLA(ticket: any, slaTracking: any, now: Date): Promise<void> {
    const dueDate = new Date(slaTracking.resolution_due);
    const timeUntilBreach = dueDate.getTime() - now.getTime();
    const minutesUntilBreach = Math.floor(timeUntilBreach / 60000);
    
    if (minutesUntilBreach <= 30 && minutesUntilBreach > 15) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_15MIN, minutesUntilBreach);
    } else if (minutesUntilBreach <= 15 && minutesUntilBreach > 0) {
      await this.sendSLAWarning(ticket, NotificationType.SLA_WARNING_5MIN, minutesUntilBreach);
    } else if (minutesUntilBreach <= 0) {
      await this.sendSLABreach(ticket, 'resolution');
    }
  }
  
  private async sendSLAWarning(ticket: any, type: NotificationType, minutesRemaining: number): Promise<void> {
    const priority = minutesRemaining <= 5 ? NotificationPriority.HIGH : NotificationPriority.MEDIUM;
    
    // Notificar al agente asignado
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: type,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: priority,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Atender Urgente',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          minutesRemaining: minutesRemaining.toString(),
          timeUnit: minutesRemaining === 1 ? 'minuto' : 'minutos'
        }
      });
    }
    
    // Notificar al supervisor si quedan menos de 5 minutos
    if (minutesRemaining <= 5) {
      const supervisor = await this.getTicketSupervisor(ticket.id);
      if (supervisor) {
        await this.notificationEngine.createNotification({
          userId: supervisor.id,
          type: type,
          relatedEntityId: ticket.id,
          relatedEntityType: 'ticket',
          priority: NotificationPriority.HIGH,
          templateVariables: {
            ticketNumber: ticket.ticket_number,
            agentName: ticket.assigned_agent_name,
            minutesRemaining: minutesRemaining.toString()
          }
        });
      }
    }
  }
  
  private async sendSLABreach(ticket: any, slaType: string): Promise<void> {
    // Notificar al agente asignado
    if (ticket.assigned_agent_id) {
      await this.notificationEngine.createNotification({
        userId: ticket.assigned_agent_id,
        type: NotificationType.SLA_BREACH,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        actionLabel: 'Atender Inmediatamente',
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          ticketSubject: ticket.subject,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'Resolución'
        }
      });
    }
    
    // Notificar al supervisor
    const supervisor = await this.getTicketSupervisor(ticket.id);
    if (supervisor) {
      await this.notificationEngine.createNotification({
        userId: supervisor.id,
        type: NotificationType.SLA_BREACH,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        requiresAction: true,
        actionUrl: `/helpdesk/tickets/${ticket.id}`,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          agentName: ticket.assigned_agent_name,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'Resolución'
        }
      });
    }
    
    // Notificar al manager para incumplimientos críticos
    const manager = await this.getHelpdeskManager();
    if (manager) {
      await this.notificationEngine.createNotification({
        userId: manager.id,
        type: NotificationType.SLA_CRITICAL,
        relatedEntityId: ticket.id,
        relatedEntityType: 'ticket',
        priority: NotificationPriority.CRITICAL,
        templateVariables: {
          ticketNumber: ticket.ticket_number,
          slaType: slaType === 'first_response' ? 'Primera Respuesta' : 'Resolución',
          agentName: ticket.assigned_agent_name
export function NotificationSettings() {
  const { user } = useAuth();
  const [settings, setSettings] = useState<NotificationSettings[]>([]);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  
  // Tipos de notificación disponibles
  const notificationTypes = [
    { 
      type: NotificationType.TICKET_ASSIGNED, 
      name: 'Ticket Asignado',
      description: 'Cuando se te asigna un nuevo ticket',
      category: 'ticket',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL]
    },
    {
      type: NotificationType.TICKET_UPDATED,
      name: 'Ticket Actualizado', 
      description: 'Cuando un ticket que sigues es actualizado',
      category: 'ticket',
      defaultChannels: [NotificationChannel.IN_APP]
    },
    {
      type: NotificationType.SLA_WARNING_15MIN,
      name: 'Alerta SLA 15 min',
      description: 'Cuando faltan 15 minutos para incumplir SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.SLA_WARNING_5MIN,
      name: 'Alerta SLA 5 min',
      description: 'Cuando faltan 5 minutos para incumplir SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.SLA_BREACH,
      name: 'Incumplimiento SLA',
      description: 'Cuando se incumple un SLA',
      category: 'sla',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL, NotificationChannel.SMS, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.NEW_CHAT_MESSAGE,
      name: 'Nuevo Mensaje Chat',
      description: 'Cuando recibes un mensaje en chat',
      category: 'chat',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.SOUND]
    },
    {
      type: NotificationType.ESCALATION_RECEIVED,
      name: 'Escalación Recibida',
      description: 'Cuando recibes una escalación',
      category: 'escalation',
      defaultChannels: [NotificationChannel.IN_APP, NotificationChannel.EMAIL]
    },
    {
      type: NotificationType.SATISFACTION_SURVEY,
      name: 'Encuesta Satisfacción',
      description: 'Resultados de encuestas de satisfacción',
      category: 'satisfaction',
      defaultChannels: [NotificationChannel.IN_APP]
    }
  ];
  
  useEffect(() => {
    loadSettings();
  }, []);
  
  const loadSettings = async () => {
    if (!user) return;
    
    try {
      setLoading(true);
      
      // Cargar configuraciones existentes
      const { data: existingSettings } = await supabase
        .from('helpdesk_notification_settings')
        .select('*')
        .eq('user_id', user.id);
      
      // Crear configuraciones por defecto para tipos que no existen
      const existingTypes = existingSettings?.map(s => s.notification_type) || [];
      const missingTypes = notificationTypes.filter(t => !existingTypes.includes(t.type));
      
      if (missingTypes.length > 0) {
        const defaultSettings = missingTypes.map(t => ({
          user_id: user.id,
          notification_type: t.type,
          enabled_channels: t.defaultChannels,
          is_enabled: true,
          batch_enabled: false,
          batch_frequency_minutes: 60
        }));
        
        await supabase
          .from('helpdesk_notification_settings')
          .insert(defaultSettings);
      }
      
      // Cargar todas las configuraciones
      const { data: allSettings, error } = await supabase
        .from('helpdesk_notification_settings')
        .select('*')
        .eq('user_id', user.id);
      
      if (error) throw error;
      
      setSettings(allSettings || []);
      
    } catch (error) {
      console.error('Error loading notification settings:', error);
    } finally {
      setLoading(false);
    }
  };
  
  const updateSetting = async (
    notificationType: NotificationType, 
    updates: Partial<NotificationSettings>
  ) => {
    try {
      setSaving(true);
      
      const { error } = await supabase
        .from('helpdesk_notification_settings')
        .update(updates)
        .eq('user_id', user.id)
        .eq('notification_type', notificationType);
      
      if (error) throw error;
      
      // Actualizar estado local
      setSettings(prev => 
        prev.map(s => 
          s.notificationType === notificationType 
            ? { ...s, ...updates }
            : s
        )
      );
      
    } catch (error) {
      console.error('Error updating notification setting:', error);
    } finally {
      setSaving(false);
    }
  };
  
  const getSettingForType = (type: NotificationType) => {
    return settings.find(s => s.notificationType === type);
  };
  
  if (loading) {
    return (
      <div className="p-6 text-center">
        <LoadingSpinner />
        <p className="mt-2 text-gray-500">Cargando configuración...</p>
      </div>
    );
  }
  
  return (
    <div className="max-w-4xl mx-auto p-6">
      <div className="bg-white dark:bg-gray-800 rounded-lg shadow">
        <div className="px-6 py-4 border-b border-gray-200 dark:border-gray-700">
          <h2 className="text-xl font-semibold text-gray-900 dark:text-white">
            Configuración de Notificaciones
          </h2>
          <p className="mt-1 text-sm text-gray-500">
            Personaliza cómo y cuándo recibes notificaciones del sistema Helpdesk
          </p>
        </div>
        
        <div className="p-6">
          {/* Configuración global */}
          <div className="mb-8">
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              Configuración Global
            </h3>
            
            <div className="space-y-4">
              <div className="flex items-center justify-between">
                <div>
                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    Horas Silenciosas
                  </label>
                  <p className="text-sm text-gray-500">
                    No recibir notificaciones durante estas horas
                  </p>
                </div>
                <div className="flex items-center gap-2">
                  <input
                    type="time"
                    className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                    defaultValue="22:00"
                  />
                  <span className="text-gray-500">hasta</span>
                  <input
                    type="time"
                    className="px-3 py-2 border border-gray-300 rounded-md text-sm"
                    defaultValue="08:00"
                  />
                </div>
              </div>
              
              <div className="flex items-center justify-between">
                <div>
                  <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                    Días Silenciosos
                  </label>
                  <p className="text-sm text-gray-500">
                    No recibir notificaciones estos días
                  </p>
                </div>
                <div className="flex gap-2">
                  {['Dom', 'Lun', 'Mar', 'Mié', 'Jue', 'Vie', 'Sáb'].map((day, index) => (
                    <label key={day} className="flex items-center">
                      <input
                        type="checkbox"
                        className="mr-1"
                        defaultChecked={index === 0 || index === 6}
                      />
                      <span className="text-xs">{day}</span>
                    </label>
                  ))}
                </div>
              </div>
            </div>
          </div>
          
          {/* Configuración por tipo */}
          <div>
            <h3 className="text-lg font-medium text-gray-900 dark:text-white mb-4">
              Configuración por Tipo de Notificación
            </h3>
            
            <div className="space-y-6">
              {notificationTypes.map(notifType => {
                const setting = getSettingForType(notifType.type);
                
                return (
                  <div key={notifType.type} className="border border-gray-200 dark:border-gray-700 rounded-lg p-4">
                    <div className="flex items-start justify-between mb-4">
                      <div>
                        <h4 className="font-medium text-gray-900 dark:text-white">
                          {notifType.name}
                        </h4>
                        <p className="text-sm text-gray-500 mt-1">
                          {notifType.description}
                        </p>
                      </div>
                      
                      <label className="flex items-center">
                        <input
                          type="checkbox"
                          checked={setting?.isEnabled ?? true}
                          onChange={(e) => updateSetting(notifType.type, {
                            isEnabled: e.target.checked
                          })}
                          className="mr-2"
                        />
                        <span className="text-sm">Habilitado</span>
                      </label>
                    </div>
                    
                    {setting?.isEnabled && (
                      <div className="space-y-4">
                        {/* Canales de entrega */}
                        <div>
                          <label className="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">
                            Canales de Entrega
                          </label>
                          <div className="flex flex-wrap gap-3">
                            {Object.values(NotificationChannel).map(channel => (
                              <label key={channel} className="flex items-center">
                                <input
                                  type="checkbox"
                                  checked={setting?.enabledChannels?.includes(channel) ?? false}
                                  onChange={(e) => {
                                    const currentChannels = setting?.enabledChannels || [];
                                    const newChannels = e.target.checked
                                      ? [...currentChannels, channel]
                                      : currentChannels.filter(c => c !== channel);
                                    
                                    updateSetting(notifType.type, {
                                      enabledChannels: newChannels
                                    });
                                  }}
                                  className="mr-2"
                                />
                                <span className="text-sm capitalize">
                                  {channel.replace('_', ' ')}
                                </span>
                              </label>
                            ))}
                          </div>
                        </div>
                        
                        {/* Configuración de agrupamiento */}
                        <div className="flex items-center justify-between">
                          <div>
                            <label className="text-sm font-medium text-gray-700 dark:text-gray-300">
                              Agrupar Notificaciones
                            </label>
                            <p className="text-sm text-gray-500">
                              Enviar notificaciones en lotes en lugar de individuales
                            </p>
                          </div>
                          <div className="flex items-center gap-2">
                            <input
                              type="checkbox"
                              checked={setting?.batchEnabled ?? false}
                              onChange={(e) => updateSetting(notifType.type, {
                                batchEnabled: e.target.checked
                              })}
                            />
                            {setting?.batchEnabled && (
                              <select
                                value={setting?.batchFrequencyMinutes || 60}
                                onChange={(e) => updateSetting(notifType.type, {
                                  batchFrequencyMinutes: parseInt(e.target.value)
                                })}
                                className="ml-2 px-2 py-1 border border-gray-300 rounded text-sm"
                              >
                                <option value={15}>15 min</option>
                                <option value={30}>30 min</option>
                                <option value={60}>1 hora</option>
                                <option value={120}>2 horas</option>
                                <option value={240}>4 horas</option>
                              </select>
                            )}
                          </div>
                        </div>
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          </div>
          
          {/* Botones de acción */}
          <div className="mt-8 flex justify-end gap-3">
            <button
              onClick={() => window.location.reload()}
              className="px-4 py-2 text-sm font-medium text-gray-700 bg-white border border-gray-300 rounded-md hover:bg-gray-50"
            >
              Restablecer
            </button>
            <button
              disabled={saving}
              className="px-4 py-2 text-sm font-medium text-white bg-blue-600 border border-transparent rounded-md hover:bg-blue-700 disabled:opacity-50"
            >
              {saving ? 'Guardando...' : 'Guardar Configuración'}
            </button>
          </div>
        </div>
      </div>
    </div>
  );
}
```

**9.6 Plantillas de Notificación Predefinidas**

```sql
-- Insertar plantillas predefinidas para el sistema de notificaciones
INSERT INTO helpdesk_notification_templates (type, name, in_app_title, in_app_message, email_subject, email_html, priority, category, available_variables) VALUES

-- Plantillas de Tickets
('ticket_assigned', 'Ticket Asignado', 
 'Nuevo ticket asignado: {{ticketNumber}}',
 'Se te ha asignado el ticket {{ticketNumber}} - {{ticketSubject}}. Cliente: {{customerName}}',
 'Nuevo ticket asignado - {{ticketNumber}}',
 '<h2>Ticket Asignado</h2><p>Hola,</p><p>Se te ha asignado un nuevo ticket:</p><ul><li><strong>Número:</strong> {{ticketNumber}}</li><li><strong>Asunto:</strong> {{ticketSubject}}</li><li><strong>Cliente:</strong> {{customerName}}</li><li><strong>Prioridad:</strong> {{priority}}</li></ul><p>Por favor, atiende este ticket a la brevedad.</p>',
 'medium', 'ticket', 
 ARRAY['ticketNumber', 'ticketSubject', 'customerName', 'priority']),

('sla_warning_15min', 'Alerta SLA 15 Minutos',
 'SLA: {{minutesRemaining}} minutos restantes - {{ticketNumber}}',
 'Atención: Faltan {{minutesRemaining}} minutos para incumplir el SLA de {{slaType}} del ticket {{ticketNumber}}',
 'URGENTE: SLA próximo a vencer - {{ticketNumber}}',
 '<h2 style="color: orange;">⚠️ Alerta de SLA</h2><p>El ticket {{ticketNumber}} está próximo a incumplir su SLA de {{slaType}}.</p><p><strong>Tiempo restante:</strong> {{minutesRemaining}} minutos</p><p>Por favor, atiende este ticket inmediatamente.</p>',
 'high', 'sla',
 ARRAY['ticketNumber', 'minutesRemaining', 'slaType']),

('sla_breach', 'Incumplimiento SLA',
 'SLA INCUMPLIDO: {{ticketNumber}}',
 'CRÍTICO: Se ha incumplido el SLA de {{slaType}} para el ticket {{ticketNumber}}',
 'CRÍTICO: Incumplimiento de SLA - {{ticketNumber}}',
 '<h2 style="color: red;">🚨 INCUMPLIMIENTO DE SLA</h2><p>Se ha incumplido el SLA de {{slaType}} para el ticket {{ticketNumber}}.</p><p>Requiere atención inmediata del supervisor.</p>',
 'critical', 'sla',
 ARRAY['ticketNumber', 'slaType', 'agentName']),

-- Plantillas de Chat
('new_chat_message', 'Nuevo Mensaje Chat',
 'Mensaje de {{customerName}}',
 'Nuevo mensaje en chat: "{{messagePreview}}"',
 'Nuevo mensaje de chat - {{customerName}}',
 '<h2>Nuevo Mensaje de Chat</h2><p>Tienes un nuevo mensaje de {{customerName}}:</p><blockquote>{{messagePreview}}</blockquote><p>Tiempo de espera: {{waitTime}}</p>',
 'high', 'chat',
 ARRAY['customerName', 'messagePreview', 'waitTime']),

-- Plantillas de Escalación
('escalation_received', 'Escalación Recibida',
 'Escalación recibida: {{ticketNumber}}',
 'Has recibido una escalación del ticket {{ticketNumber}} de {{escalatedFrom}}. Razón: {{reason}}',
 'Escalación recibida - {{ticketNumber}}',
 '<h2>📈 Escalación Recibida</h2><p>Has recibido una escalación:</p><ul><li><strong>Ticket:</strong> {{ticketNumber}}</li><li><strong>De:</strong> {{escalatedFrom}}</li><li><strong>Razón:</strong> {{reason}}</li><li><strong>Urgencia:</strong> {{urgency}}</li></ul>',
 'high', 'escalation',
 ARRAY['ticketNumber', 'escalatedFrom', 'reason', 'urgency']);
```

9.7 Integración con Sistema Existente

**9.7.1 Middleware de Notificaciones**

```typescript
  const { notifications, markAsRead, markAllAsRead, deleteNotification } = useNotifications();
  
  const filteredNotifications = useMemo(() => {
    switch (filter) {
      case 'unread':
        return notifications.filter(n => !n.isRead);
      case 'high-priority':
        return notifications.filter(n => ['high', 'critical'].includes(n.priority));
      case 'actions':
        return notifications.filter(n => n.requiresAction);
      default:
        return notifications;
    }
  }, [notifications, filter]);
  
  const unreadCount = notifications.filter(n => !n.isRead).length;
  const criticalCount = notifications.filter(n => n.priority === 'critical').length;
  
  return (
    <div className="relative">
      {/* Botón de notificaciones con badge */}
      <button 
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-900 dark:text-gray-300 hover:dark:text-white transition-colors"
      >
        <BellIcon className="h-6 w-6" />
        
        {/* Badge de notificaciones no leídas */}
        {unreadCount > 0 && (
          <span className="absolute -top-1 -right-1 inline-flex items-center justify-center px-2 py-1 text-xs font-bold leading-none text-white transform translate-x-1/2 -translate-y-1/2 bg-red-600 rounded-full min-w-[20px]">
            {unreadCount > 99 ? '99+' : unreadCount}
          </span>
        )}
        
        {/* Indicator de notificaciones críticas */}
        {criticalCount > 0 && (
          <span className="absolute top-0 right-0 inline-flex items-center justify-center w-3 h-3 text-xs font-bold leading-none text-white bg-red-600 rounded-full animate-pulse" />
        )}
      </button>
      
      {/* Panel de notificaciones */}
      <Transition
        show={isOpen}
        enter="transition ease-out duration-200"
        enterFrom="transform opacity-0 scale-95"
        enterTo="transform opacity-100 scale-100"
        leave="transition ease-in duration-75"
        leaveFrom="transform opacity-100 scale-100"
        leaveTo="transform opacity-0 scale-95"
      >
        <div className="absolute right-0 z-50 mt-2 w-96 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 max-h-[600px] flex flex-col">
          
          {/* Header */}
          <div className="p-4 border-b border-gray-200 dark:border-gray-700 flex-shrink-0">
            <div className="flex items-center justify-between mb-3">
              <h3 className="text-lg font-semibold text-gray-900 dark:text-white">
                Notificaciones
              </h3>
              <button
                onClick={() => setIsOpen(false)}
                className="text-gray-400 hover:text-gray-600 dark:hover:text-gray-300"
              >
                <XMarkIcon className="h-5 w-5" />
              </button>
            </div>
            
            {/* Filtros */}
            <div className="flex gap-2">
              <NotificationFilters filter={filter} setFilter={setFilter} />
              {unreadCount > 0 && (
                <button 
                  onClick={markAllAsRead}
                  className="text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300"
                >
                  Marcar todas como leídas
                </button>
              )}
            </div>
          </div>
          
          {/* Lista de notificaciones */}
          <div className="flex-1 overflow-y-auto">
            {filteredNotifications.length > 0 ? (
              <div className="divide-y divide-gray-200 dark:divide-gray-700">
                {filteredNotifications.map(notification => (
                  <NotificationItem 
                    key={notification.id}
                    notification={notification}
                    onMarkAsRead={markAsRead}
                    onDelete={deleteNotification}
                  />
                ))}
              </div>
            ) : (
              <div className="p-8 text-center text-gray-500 dark:text-gray-400">
                <BellSlashIcon className="h-12 w-12 mx-auto mb-2 text-gray-300 dark:text-gray-600" />
                <p className="text-sm">
                  {filter === 'all' ? 'No hay notificaciones' : `No hay notificaciones ${filter}`}
                </p>
              </div>
            )}
          </div>
          
          {/* Footer */}
          {filteredNotifications.length > 0 && (
            <div className="p-4 border-t border-gray-200 dark:border-gray-700 flex-shrink-0">
              <button 
                onClick={() => {
                  setIsOpen(false);
                  // Navegar a página completa de notificaciones
                }}
                className="w-full text-center text-sm text-blue-600 hover:text-blue-800 dark:text-blue-400 dark:hover:text-blue-300 font-medium"
              >
                Ver todas las notificaciones
              </button>
            </div>
          )}
        </div>
      </Transition>
    </div>
  );
};

type NotificationFilter = 'all' | 'unread' | 'high-priority' | 'actions';

const NotificationFilters: React.FC<{
  filter: NotificationFilter;
  setFilter: (filter: NotificationFilter) => void;
}> = ({ filter, setFilter }) => {
  const filters = [
    { key: 'all', label: 'Todas', icon: InboxIcon },
    { key: 'unread', label: 'No leídas', icon: EnvelopeIcon },
    { key: 'high-priority', label: 'Prioritarias', icon: ExclamationTriangleIcon },
    { key: 'actions', label: 'Acciones', icon: PlayIcon }
  ];
  
  return (
    <div className="flex gap-1">
      {filters.map(({ key, label, icon: Icon }) => (
        <button
          key={key}
          onClick={() => setFilter(key as NotificationFilter)}
          className={`px-3 py-1 text-xs font-medium rounded-full transition-colors ${
            filter === key
              ? 'bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200'
              : 'text-gray-600 hover:text-gray-900 dark:text-gray-400 dark:hover:text-gray-200'
          }`}
        >
          <Icon className="h-3 w-3 inline mr-1" />
          {label}
        </button>
      ))}
    </div>
  );
};
```

**9.5.2 Item de Notificación**

```typescript
const NotificationItem: React.FC<{
  notification: HelpdeskNotification;
  onMarkAsRead: (id: string) => void;
  onDelete: (id: string) => void;
}> = ({ notification, onMarkAsRead, onDelete }) => {
  const [isExpanded, setIsExpanded] = useState(false);
  
  const handleClick = () => {
    if (!notification.isRead) {
      onMarkAsRead(notification.id);
    }
    
    if (notification.actionUrl) {
      // Navegar a la URL de acción
      window.location.href = notification.actionUrl;
    } else {
      setIsExpanded(!isExpanded);
    }
  };
  
  const getPriorityColor = (priority: NotificationPriority) => {
    switch (priority) {
      case NotificationPriority.CRITICAL:
        return 'bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200';
      case NotificationPriority.HIGH:
        return 'bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200';
      case NotificationPriority.MEDIUM:
        return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200';
    }
  };
  
  const getCategoryIcon = (category: NotificationCategory) => {
    switch (category) {
      case NotificationCategory.TICKET:
        return TicketIcon;
      case NotificationCategory.SLA:
        return ClockIcon;
      case NotificationCategory.CHAT:
        return ChatBubbleLeftRightIcon;
      case NotificationCategory.ESCALATION:
        return ArrowTrendingUpIcon;
      case NotificationCategory.INTEGRATION:
        return LinkIcon;
      case NotificationCategory.SYSTEM:
        return CogIcon;
      case NotificationCategory.SATISFACTION:
        return StarIcon;
      default:
        return BellIcon;
    }
  };
  
  const Icon = getCategoryIcon(notification.category);
  
  return (
    <div 
      className={`p-4 hover:bg-gray-50 dark:hover:bg-gray-700 transition-colors cursor-pointer ${
        !notification.isRead ? 'bg-blue-50 dark:bg-blue-900/20' : ''
      }`}
      onClick={handleClick}
    >
      <div className="flex items-start gap-3">
        
        {/* Icono de categoría */}
        <div className={`flex-shrink-0 w-8 h-8 rounded-full flex items-center justify-center ${
          notification.priority === NotificationPriority.CRITICAL ? 'bg-red-100 dark:bg-red-900' :
          notification.priority === NotificationPriority.HIGH ? 'bg-orange-100 dark:bg-orange-900' :
          'bg-gray-100 dark:bg-gray-700'
        }`}>
          <Icon className={`h-4 w-4 ${
            notification.priority === NotificationPriority.CRITICAL ? 'text-red-600 dark:text-red-400' :
            notification.priority === NotificationPriority.HIGH ? 'text-orange-600 dark:text-orange-400' :
            'text-gray-600 dark:text-gray-400'
          }`} />
        </div>
        
        {/* Contenido principal */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between">
            <div className="flex-1">
              <p className={`text-sm font-medium ${
                !notification.isRead 
                  ? 'text-gray-900 dark:text-white' 
                  : 'text-gray-700 dark:text-gray-300'
              }`}>
                {notification.title}
              </p>
              
              {/* Mensaje (truncado si no está expandido) */}
              <p className={`text-sm text-gray-600 dark:text-gray-400 mt-1 ${
                isExpanded ? '' : 'line-clamp-2'
              }`}>
                {notification.message}
              </p>
            </div>
            
            {/* Indicador de no leído */}
            {!notification.isRead && (
              <div className="flex-shrink-0 w-2 h-2 bg-blue-600 rounded-full ml-2 mt-1"></div>
            )}
          </div>
          
          {/* Metadatos */}
          <div className="flex items-center gap-2 mt-2">
            
            {/* Badge de prioridad */}
            <span className={`inline-flex items-center px-2 py-0.5 rounded-full text-xs font-medium ${getPriorityColor(notification.priority)}`}>
              {notification.priority.toUpperCase()}
            </span>
            
            {/* Tiempo transcurrido */}
            <span className="text-xs text-gray-500 dark:text-gray-400">
              {formatTimeAgo(notification.createdAt)}
            </span>
            
            {/* Botón de acción si está disponible */}
            {notification.requiresAction && notification.actionLabel && (
              <span className="inline-flex items-center text-xs text-blue-600 dark:text-blue-400 font-medium">
                <PlayIcon className="h-3 w-3 mr-1" />
                {notification.actionLabel}
              </span>
            )}
          </div>
        </div>
        
        {/* Menú de acciones */}
        <div className="flex-shrink-0">
          <Menu as="div" className="relative">
            <Menu.Button className="p-1 text-gray-400 hover:text-gray-600 dark:hover:text-gray-300">
              <EllipsisHorizontalIcon className="h-4 w-4" />
            </Menu.Button>
            <Menu.Items className="absolute right-0 z-10 mt-1 w-48 bg-white dark:bg-gray-800 rounded-md shadow-lg border border-gray-200 dark:border-gray-700">
              {!notification.isRead && (
                <Menu.Item>
                  {({ active }) => (
                    <button
                      onClick={(e) => {
                        e.stopPropagation();
                        onMarkAsRead(notification.id);
                      }}
                      className={`${
                        active ? 'bg-gray-100 dark:bg-gray-700' : ''
                      } block w-full text-left px-4 py-2 text-sm text-gray-700 dark:text-gray-300`}
                    >
                      Marcar como leída
                    </button>
                  )}
                </Menu.Item>
              )}
              <Menu.Item>
                {({ active }) => (
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      onDelete(notification.id);
                    }}
                    className={`${
                      active ? 'bg-gray-100 dark:bg-gray-700' : ''
                    } block w-full text-left px-4 py-2 text-sm text-red-600 dark:text-red-400`}
                  >
                    Eliminar
                  </button>
                )}
              </Menu.Item>
            </Menu.Items>
          </Menu>
        </div>
      </div>
    </div>
  );
};

// Función auxiliar para formatear tiempo transcurrido
const formatTimeAgo = (date: Date): string => {
  const now = new Date();
  const diffMs = now.getTime() - date.getTime();
  const diffMins = Math.floor(diffMs / 60000);
  const diffHours = Math.floor(diffMins / 60);
  const diffDays = Math.floor(diffHours / 24);
  
  if (diffMins < 1) return 'Ahora';
  if (diffMins < 60) return `${diffMins}m`;
  if (diffHours < 24) return `${diffHours}h`;
  if (diffDays < 7) return `${diffDays}d`;
  
  return date.toLocaleDateString();
};
```

═══════════════════════════════════════════════════════════════════

🛠️ 10. IMPLEMENTACIÓN TÉCNICA

9.1 Estructura de Archivos

```
src/
├── modules/
│   └── helpdesk/
│       ├── components/
│       │   ├── Chat/
│       │   │   ├── ChatInterface.tsx
│       │   │   ├── MessageBubble.tsx
│       │   │   ├── TypingIndicator.tsx
│       │   │   ├── FileUpload.tsx
│       │   │   └── EmojiPicker.tsx
│       │   ├── Tickets/
│       │   │   ├── TicketList.tsx
│       │   │   ├── TicketCard.tsx
│       │   │   ├── TicketFilters.tsx
│       │   │   ├── TicketForm.tsx
│       │   │   └── TicketDetails.tsx
│       │   ├── Dashboard/
│       │   │   ├── SLAWidget.tsx
│       │   │   ├── CriticalTicketsWidget.tsx
│       │   │   ├── WorkloadWidget.tsx
│       │   │   ├── SatisfactionWidget.tsx
│       │   │   └── MetricsChart.tsx
│       │   └── Admin/
│       │       ├── CategoryManagement.tsx
│       │       ├── PriorityManagement.tsx
│       │       ├── SLAConfiguration.tsx
│       │       └── EscalationRules.tsx
│       ├── hooks/
│       │   ├── useHelpdeskTickets.ts
│       │   ├── useHelpdeskChat.ts
│       │   ├── useHelpdeskMetrics.ts
│       │   ├── useHelpdeskSLA.ts
│       │   ├── useHelpdeskEscalation.ts
│       │   └── useHelpdeskPermissions.ts
│       ├── services/
│       │   ├── HelpdeskService.ts
│       │   ├── ChatService.ts
│       │   ├── SLAService.ts
│       │   ├── EscalationService.ts
│       │   ├── MetricsService.ts
│       │   └── IntegrationService.ts
│       ├── types/
│       │   ├── ticket.types.ts
│       │   ├── chat.types.ts
│       │   ├── sla.types.ts
│       │   ├── metrics.types.ts
│       │   └── index.ts
│       └── utils/
│           ├── ticketUtils.ts
│           ├── slaUtils.ts
│           ├── chatUtils.ts
│           └── metricsUtils.ts
├── pages/
│   └── helpdesk/
│       ├── HelpdeskDashboard.tsx
│       ├── TicketsPage.tsx
│       ├── ChatPage.tsx
│       ├── ReportsPage.tsx
│       └── ConfigurationPage.tsx
└── stores/
    └── helpdeskStore.ts
```

9.2 Hooks Principales

9.2.1 useHelpdeskTickets
```typescript
export function useHelpdeskTickets() {
    const [tickets, setTickets] = useState<HelpdeskTicket[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [filters, setFilters] = useState<TicketFilters>({});
    const { user } = useAuth();
    
    // Cargar tickets con filtros
    const fetchTickets = useCallback(async (ticketFilters?: TicketFilters) => {
        try {
            setLoading(true);
            setError(null);
            
            let query = supabase
                .from('helpdesk_tickets')
                .select(`
                    *,
                    priority:helpdesk_priorities(*),
                    category:helpdesk_categories(*),
                    status:helpdesk_statuses(*),
                    requester:user_profiles!requester_user_id(*),
                    assigned_agent:user_profiles!assigned_agent_id(*),
                    sla_tracking:helpdesk_sla_tracking(*)
                `)
                .order('created_at', { ascending: false });
            
            // Aplicar filtros
            if (ticketFilters) {
                if (ticketFilters.status?.length) {
                    query = query.in('status_id', ticketFilters.status);
                }
                if (ticketFilters.priority?.length) {
                    query = query.in('priority_id', ticketFilters.priority);
                }
                if (ticketFilters.assignedTo?.length) {
                    query = query.in('assigned_agent_id', ticketFilters.assignedTo);
                }
                if (ticketFilters.searchTerm) {
                    query = query.or(`subject.ilike.%${ticketFilters.searchTerm}%,description.ilike.%${ticketFilters.searchTerm}%`);
                }
            }
            
            const { data, error: fetchError } = await query;
            
            if (fetchError) throw fetchError;
            
            const mappedTickets = data.map(mapTicketFromDB);
            setTickets(mappedTickets);
            
        } catch (err) {
            console.error('Error fetching tickets:', err);
            setError(err instanceof Error ? err.message : 'Error desconocido');
        } finally {
            setLoading(false);
        }
    }, []);
    
    // Crear nuevo ticket
    const createTicket = async (ticketData: CreateTicketData): Promise<HelpdeskTicket | null> => {
        try {
            const { data, error } = await supabase
                .from('helpdesk_tickets')
                .insert({
                    subject: ticketData.subject,
                    description: ticketData.description,
                    priority_id: ticketData.priorityId,
                    category_id: ticketData.categoryId,
                    requester_user_id: user?.id,
                    source_type: 'chat'
                })
                .select()
                .single();
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return mapTicketFromDB(data);
            
        } catch (err) {
            console.error('Error creating ticket:', err);
            setError(err instanceof Error ? err.message : 'Error al crear ticket');
            return null;
        }
    };
    
    // Asignar ticket
    const assignTicket = async (ticketId: string, agentId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_tickets')
                .update({ 
                    assigned_agent_id: agentId,
                    updated_at: new Date().toISOString()
                })
                .eq('id', ticketId);
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return true;
            
        } catch (err) {
            console.error('Error assigning ticket:', err);
            setError(err instanceof Error ? err.message : 'Error al asignar ticket');
            return false;
        }
    };
    
    // Actualizar estado del ticket
    const updateTicketStatus = async (ticketId: string, statusId: string): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_tickets')
                .update({ 
                    status_id: statusId,
                    updated_at: new Date().toISOString()
                })
                .eq('id', ticketId);
            
            if (error) throw error;
            
            await fetchTickets(filters);
            return true;
            
        } catch (err) {
            console.error('Error updating ticket status:', err);
            setError(err instanceof Error ? err.message : 'Error al actualizar estado');
            return false;
        }
    };
    
    useEffect(() => {
        fetchTickets(filters);
    }, [fetchTickets, filters]);
    
    return {
        tickets,
        loading,
        error,
        filters,
        setFilters,
        fetchTickets,
        createTicket,
        assignTicket,
        updateTicketStatus,
        // Utilities
        getTicketById: (id: string) => tickets.find(t => t.id === id),
        getMyTickets: () => tickets.filter(t => t.assignedAgent?.id === user?.id),
        getUnassignedTickets: () => tickets.filter(t => !t.assignedAgent),
        getCriticalTickets: () => tickets.filter(t => t.priority.level === 1)
    };
}
```

9.2.2 useHelpdeskChat
```typescript
export function useHelpdeskChat(ticketId: string) {
    const [messages, setMessages] = useState<ChatMessage[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);
    const [isTyping, setIsTyping] = useState(false);
    const [typingUsers, setTypingUsers] = useState<User[]>([]);
    const { user } = useAuth();
    
    // Cargar mensajes del ticket
    const fetchMessages = useCallback(async () => {
        try {
            setLoading(true);
            setError(null);
            
            const { data, error: fetchError } = await supabase
                .from('helpdesk_chat_messages')
                .select(`
                    *,
                    sender:user_profiles(*)
                `)
                .eq('ticket_id', ticketId)
                .order('created_at', { ascending: true });
            
            if (fetchError) throw fetchError;
            
            const mappedMessages = data.map(mapMessageFromDB);
            setMessages(mappedMessages);
            
        } catch (err) {
            console.error('Error fetching messages:', err);
            setError(err instanceof Error ? err.message : 'Error al cargar mensajes');
        } finally {
            setLoading(false);
        }
    }, [ticketId]);
    
    // Enviar mensaje
    const sendMessage = async (content: string, messageType: MessageType = 'text', isInternal = false): Promise<boolean> => {
        try {
            const { error } = await supabase
                .from('helpdesk_chat_messages')
                .insert({
                    ticket_id: ticketId,
                    sender_user_id: user?.id,
                    message_type: messageType,
                    content,
                    is_internal: isInternal
                });
            
            if (error) throw error;
            
            return true;
            
        } catch (err) {
            console.error('Error sending message:', err);
            setError(err instanceof Error ? err.message : 'Error al enviar mensaje');
            return false;
        }
    };
    
    // Configurar suscripción en tiempo real
    useEffect(() => {
        const channel = supabase
            .channel(`chat_${ticketId}`)
            .on('postgres_changes', 
                { 
                    event: 'INSERT', 
                    schema: 'public', 
                    table: 'helpdesk_chat_messages',
                    filter: `ticket_id=eq.${ticketId}`
                },
                async (payload) => {
                    const newMessage = await fetchMessageDetails(payload.new.id);
                    if (newMessage) {
                        setMessages(prev => [...prev, newMessage]);
                    }
                }
            )
            .subscribe();
        
        return () => {
            supabase.removeChannel(channel);
        };
    }, [ticketId]);
    
    // Cargar mensajes al montar
    useEffect(() => {
        fetchMessages();
    }, [fetchMessages]);
    
    return {
        messages,
        loading,
        error,
        isTyping,
        typingUsers,
        sendMessage,
        refreshMessages: fetchMessages,
        // Utilities
        getLastMessage: () => messages[messages.length - 1],
        getMessagesByType: (type: MessageType) => messages.filter(m => m.messageType === type),
        getInternalMessages: () => messages.filter(m => m.isInternal)
    };
}
```

9.3 Servicios

9.3.1 SLA Service
```typescript
class SLAService {
    async calculateSLAForTicket(ticket: HelpdeskTicket): Promise<SLACalculation> {
        const { data: slaSettings } = await supabase
            .rpc('calculate_sla_dates', {
                p_priority_id: ticket.priority.id,
                p_category_id: ticket.category.id,
                p_created_at: ticket.createdAt
            });
        
        const now = new Date();
        const firstResponseDue = new Date(slaSettings.first_response_due);
        const resolutionDue = new Date(slaSettings.resolution_due);
        
        return {
            firstResponse: {
                dueDate: firstResponseDue,
                status: this.getSLAStatus(ticket.firstResponseAt, firstResponseDue, now),
                timeRemaining: Math.max(0, firstResponseDue.getTime() - now.getTime()) / 60000
            },
            resolution: {
                dueDate: resolutionDue,
                status: this.getSLAStatus(ticket.resolutionDate, resolutionDue, now),
                timeRemaining: Math.max(0, resolutionDue.getTime() - now.getTime()) / 60000
            }
        };
    }
    
    private getSLAStatus(actualDate: Date | null, dueDate: Date, currentDate: Date): SLAStatus {
        if (actualDate) {
            return actualDate <= dueDate ? 'compliant' : 'breached';
        }
        
        const timeRemaining = dueDate.getTime() - currentDate.getTime();
        const warningThreshold = 20 * 60 * 1000; // 20 minutos
        
        if (timeRemaining <= 0) return 'breached';
        if (timeRemaining <= warningThreshold) return 'at_risk';
        return 'compliant';
    }
    
    async updateSLATracking(ticketId: string, eventType: SLAEventType): Promise<void> {
        await supabase
            .from('helpdesk_sla_tracking')
            .update({
                achieved_date: new Date().toISOString(),
                is_breached: false,
                updated_at: new Date().toISOString()
            })
            .eq('ticket_id', ticketId)
            .eq('sla_type', eventType);
    }
}
```

9.3.2 Escalation Service
```typescript
class EscalationService {
    async processAutomaticEscalations(): Promise<void> {
        const rules = await this.getActiveEscalationRules();
        const candidateTickets = await this.getEscalationCandidates();
        
        for (const ticket of candidateTickets) {
            for (const rule of rules) {
                if (await this.shouldEscalate(ticket, rule)) {
                    await this.executeEscalation(ticket, rule);
                }
            }
        }
    }
    
    private async shouldEscalate(ticket: HelpdeskTicket, rule: EscalationRule): Promise<boolean> {
        switch (rule.trigger.type) {
            case 'time_based':
                const timeSinceCreation = Date.now() - new Date(ticket.createdAt).getTime();
                return timeSinceCreation > (rule.trigger.conditions.timeThresholdMinutes || 0) * 60000;
                
            case 'sla_breach':
                const slaCalculation = await new SLAService().calculateSLAForTicket(ticket);
                return rule.trigger.conditions.slaType === 'first_response' 
                    ? slaCalculation.firstResponse.status === 'breached'
                    : slaCalculation.resolution.status === 'breached';
                    
            case 'priority_based':
                return ticket.priority.level <= (rule.trigger.conditions.priorityLevel || 5);
                
            default:
                return false;
        }
    }
    
    private async executeEscalation(ticket: HelpdeskTicket, rule: EscalationRule): Promise<void> {
        // Registrar escalación
        await supabase
            .from('helpdesk_escalations')
            .insert({
                ticket_id: ticket.id,
                escalation_type: rule.trigger.type,
                from_user_id: ticket.assignedAgent?.id,
                to_user_id: rule.action.targetId,
                reason: `Escalación automática: ${rule.name}`
            });
        
        // Actualizar ticket
        await supabase
            .from('helpdesk_tickets')
            .update({
                assigned_agent_id: rule.action.targetId,
                escalated_to_user_id: rule.action.targetId,
                updated_at: new Date().toISOString()
            })
            .eq('id', ticket.id);
        
        // Enviar notificaciones
        await this.sendEscalationNotifications(ticket, rule);
    }
}
```

═══════════════════════════════════════════════════════════════════

🚀 10. PLAN DE IMPLEMENTACIÓN

10.1 Cronograma de Desarrollo

**FASE 1: FUNDACIÓN (4-6 semanas)**
```
Semana 1-2: Infraestructura Base
├── Diseño de base de datos y migraciones
├── Configuración de entorno de desarrollo  
├── Setup de Supabase Realtime
└── Implementación de autenticación básica

Semana 3-4: Componentes Core
├── Estructura de archivos del módulo
├── Tipos TypeScript básicos
├── Hooks fundamentales (useHelpdeskTickets, useHelpdeskChat)
└── Servicios base (HelpdeskService, ChatService)

Semana 5-6: Chat Básico
├── Interfaz de chat en tiempo real
├── Sistema de mensajes básico
├── Soporte para archivos adjuntos
└── Indicadores de escritura
```

**FASE 2: FUNCIONALIDADES CORE (6-8 semanas)**
```
Semana 7-9: Sistema de Tickets
├── CRUD completo de tickets
├── Sistema de estados y transiciones
├── Filtros y búsqueda avanzada
├── Vista Kanban y lista

Semana 10-12: SLA Management
├── Configuración de SLA por prioridad/categoría
├── Cálculo automático de fechas SLA
├── Tracking y alertas de SLA
├── Dashboard de métricas SLA

Semana 13-14: Sistema de Escalación
├── Motor de reglas de escalación
├── Escalación automática y manual
├── Notificaciones de escalación
├── Tracking de cadena de escalación
```

**FASE 3: CARACTERÍSTICAS AVANZADAS (4-6 semanas)**
```
Semana 15-17: Integración con Casos
├── Conversión ticket → caso
├── Sincronización bidireccional de estados
├── API de integración
├── Clasificador de complejidad

Semana 18-20: Dashboard y Reportes
├── Widgets especializados
├── Reportes de performance
├── Análisis de tendencias
├── Exportación de datos
```

**FASE 4: OPTIMIZACIÓN Y DESPLIEGUE (2-4 semanas)**
```
Semana 21-22: Testing y Optimización
├── Tests unitarios (>85% coverage)
├── Tests de integración
├── Optimización de performance
├── Testing de carga

Semana 23-24: Despliegue y Documentación
├── Documentación de usuario
├── Documentación técnica
├── Despliegue en producción
├── Monitoreo y alertas
```

10.2 Fases de Implementación

**📋 FASE 1: FUNDACIÓN**

*Objetivo: Establecer la base técnica sólida*

**Entregables:**
- ✅ Base de datos completamente diseñada y migrada
- ✅ Autenticación y autorización funcionando
- ✅ Chat básico en tiempo real operativo
- ✅ Estructura de archivos y componentes base

**Criterios de Aceptación:**
- Los usuarios pueden crear tickets básicos
- El chat funciona en tiempo real entre usuarios
- La autenticación respeta los nuevos roles de HELPDESK
- Las migraciones se ejecutan sin errores

**📊 FASE 2: FUNCIONALIDADES CORE**

*Objetivo: Implementar todas las funcionalidades principales*

**Entregables:**
- ✅ Sistema completo de gestión de tickets
- ✅ SLA management completamente funcional
- ✅ Motor de escalación automática
- ✅ Dashboard básico con métricas principales

**Criterios de Aceptación:**
- Los tickets se pueden gestionar completamente (CRUD)
- El SLA se calcula y monitorea automáticamente
- Las escalaciones funcionan según reglas configuradas
- Las métricas se muestran en tiempo real

**🔄 FASE 3: INTEGRACIÓN**

*Objetivo: Conectar perfectamente con módulos existentes*

**Entregables:**
- ✅ Integración completa con módulo de Casos
- ✅ Sincronización bidireccional de estados
- ✅ API REST completa para integraciones
- ✅ Dashboard avanzado con reportes

**Criterios de Aceptación:**
- Los tickets se convierten a casos sin pérdida de datos
- Los cambios en casos se reflejan en tickets
- La API permite integraciones externas
- Los reportes son precisos y útiles

**🚀 FASE 4: OPTIMIZACIÓN**

*Objetivo: Preparar para producción y optimizar performance*

**Entregables:**
- ✅ Suite completa de tests
- ✅ Optimizaciones de performance
- ✅ Documentación completa
- ✅ Sistema en producción

**Criterios de Aceptación:**
- Coverage de tests > 85%
- Tiempo de respuesta < 100ms
- Documentación técnica completa
- Sistema estable en producción

10.3 Recursos Necesarios

**👥 EQUIPO DE DESARROLLO**

```
Rol                    | Asignación | Responsabilidades
-----------------------|------------|------------------
Tech Lead             | 1 persona  | Arquitectura, decisiones técnicas
Frontend Developer    | 2 personas | React, TypeScript, UI/UX
Backend Developer     | 1 persona  | Supabase, SQL, API
UX/UI Designer        | 1 persona  | Diseño de interfaces, usabilidad
QA Engineer           | 1 persona  | Testing, calidad
DevOps Engineer       | 0.5 persona| Despliegue, monitoreo
Product Owner         | 0.5 persona| Requisitos, priorización
```

**💻 INFRAESTRUCTURA TÉCNICA**

```
Recurso               | Especificación
---------------------|------------------
Supabase Pro         | Base de datos, Auth, Realtime
GitHub                | Control de versiones
Netlify Pro          | Hosting y CI/CD
Figma                | Diseño y prototipado
Notion               | Documentación del proyecto
```

**📊 PRESUPUESTO ESTIMADO**

```
Categoría            | Costo Mensual | Costo Total (6 meses)
--------------------|---------------|----------------------
Equipo (6 personas) | $25,000       | $150,000
Infraestructura     | $500          | $3,000
Herramientas        | $300          | $1,800
Contingencia (10%)  | $2,580        | $15,480
--------------------|---------------|----------------------
TOTAL               | $28,380       | $170,280
```

═══════════════════════════════════════════════════════════════════

📝 11. APÉNDICES

11.1 Glosario de Términos

**ANS (Acuerdo de Nivel de Servicio)**: Compromisos específicos de tiempo y calidad para la resolución de tickets.

**Escalación**: Proceso de elevar un ticket a un nivel superior de soporte cuando no puede resolverse en el nivel actual.

**FCR (First Call Resolution)**: Métrica que indica el porcentaje de tickets resueltos en el primer contacto.

**HELPDESK**: Sistema centralizado para gestión de solicitudes de soporte técnico y servicios.

**SLA (Service Level Agreement)**: Acuerdo que define los tiempos máximos de respuesta y resolución.

**Ticket**: Registro individual de una solicitud de soporte con número único de identificación.

**WebSocket**: Protocolo de comunicación bidireccional para chat en tiempo real.

11.2 Referencias Técnicas

**Documentación de APIs:**
- Supabase Documentation: https://supabase.io/docs
- React Query v4: https://tanstack.com/query/v4
- Zustand State Management: https://github.com/pmndrs/zustand
- Tailwind CSS: https://tailwindcss.com/docs

**Estándares y Mejores Prácticas:**
- ITIL 4 Framework para gestión de servicios
- TypeScript Handbook: https://www.typescriptlang.org/docs/
- React Best Practices: https://react.dev/learn
- PostgreSQL Performance Tuning Guide

**Herramientas de Desarrollo:**
- VS Code con extensiones React/TypeScript
- GitHub Actions para CI/CD
- Figma para diseño de interfaces
- Postman para testing de APIs

11.3 Casos de Uso Detallados

**CU-001: Cliente Crea Ticket Vía Chat**
```
Actor: Cliente (helpdesk_customer)
Precondiciones: Usuario autenticado en el sistema

Flujo Principal:
1. Cliente accede al portal de HELPDESK
2. Sistema muestra interfaz de chat
3. Cliente escribe su consulta/problema
4. Sistema crea automáticamente un ticket con número único
5. Sistema asigna prioridad y categoría automáticamente
6. Sistema calcula fechas SLA
7. Sistema busca agente disponible y asigna ticket
8. Agente recibe notificación de nuevo ticket
9. Chat queda establecido entre cliente y agente

Flujos Alternativos:
3a. Cliente adjunta archivos (capturas, logs)
5a. Sistema no puede determinar categoría automáticamente
    - Ticket queda en cola para clasificación manual
8a. No hay agentes disponibles
    - Ticket queda en cola general
    - Cliente recibe mensaje estimado de tiempo de espera

Postcondiciones: 
- Ticket creado y asignado
- Chat activo entre cliente y agente
- SLA iniciado y monitoreado
```

**CU-002: Agente Resuelve Ticket y Convierte a Caso**
```
Actor: Agente L3 (helpdesk_agent_l3)
Precondiciones: Ticket asignado al agente, requiere análisis complejo

Flujo Principal:
1. Agente revisa ticket y determina complejidad alta
2. Agente accede al clasificador de casos
3. Sistema presenta formulario de clasificación
4. Agente completa criterios de complejidad:
   - Historial del caso
   - Conocimiento del módulo
   - Manipulación de datos
   - Claridad de descripción
   - Causa del fallo
5. Sistema calcula puntuación automáticamente
6. Sistema determina clasificación (Alta/Media/Baja complejidad)
7. Agente confirma conversión a caso
8. Sistema crea caso en módulo existente
9. Sistema vincula ticket con caso creado
10. Sistema actualiza estado ticket a "CLASSIFIED_TO_CASE"
11. Sistema envía notificación al equipo de casos

Postcondiciones:
- Caso creado en módulo de gestión
- Ticket vinculado al caso
- Seguimiento transferido a equipo especializado
```

**CU-003: Dashboard de Manager - Análisis de SLA**
```
Actor: Manager de HELPDESK (helpdesk_manager)
Precondiciones: Usuario con permisos de manager

Flujo Principal:
1. Manager accede al dashboard especializado
2. Sistema muestra widgets principales:
   - Cumplimiento SLA general
   - Tickets críticos pendientes
   - Distribución de carga por agente
   - Satisfacción del cliente
3. Manager selecciona período específico (día/semana/mes)
4. Sistema actualiza métricas en tiempo real
5. Manager identifica áreas de mejora
6. Manager accede a reportes detallados
7. Sistema genera análisis de tendencias
8. Manager exporta reportes para presentación

Características Especiales:
- Actualización automática cada 30 segundos
- Alertas visuales para SLA en riesgo
- Drill-down en métricas específicas
- Comparación con períodos anteriores
```

═══════════════════════════════════════════════════════════════════

🎯 CONCLUSIÓN

El módulo HELPDESK representa una **transformación estratégica** del sistema de gestión de casos, elevándolo de una herramienta de gestión interna a una **plataforma integral de atención al cliente** con capacidades empresariales.

**🔑 FACTORES CRÍTICOS DE ÉXITO:**

1. **Adopción Gradual**: Implementación por fases permitirá adaptación del equipo
2. **Training Integral**: Capacitación completa en nuevos procesos y herramientas
3. **Métricas Claras**: KPIs bien definidos para medir éxito del proyecto
4. **Feedback Continuo**: Ciclos de retroalimentación con usuarios finales
5. **Soporte Post-Launch**: Acompañamiento durante primeros meses

**📈 IMPACTO PROYECTADO:**

- **Eficiencia Operacional**: Reducción 40% tiempo de primera respuesta
- **Satisfacción Cliente**: Incremento 35% en CSAT scores
- **Visibilidad Gerencial**: 100% visibilidad en métricas operacionales
- **Escalabilidad**: Capacidad para 10x crecimiento en volumen

**🚀 PRÓXIMOS PASOS:**

1. **Aprobación del Proyecto**: Revisión y aprobación de especificación
2. **Setup del Equipo**: Contratación y organización del equipo
3. **Kick-off Meeting**: Reunión de inicio con todos los stakeholders
4. **Sprint Planning**: Planificación detallada de primeros sprints

---

═══════════════════════════════════════════════════════════════════

🔗 12. INTEGRACIÓN CON SISTEMA EXISTENTE

12.1 Arquitectura de Integración

El módulo HELPDESK se integra perfectamente con el sistema existente de gestión de casos a través de múltiples puntos de conexión, manteniendo la coherencia arquitectónica y aprovechando la infraestructura actual.

**12.1.1 Diagrama de Integración**
```
┌─────────────────────────────────────────────────────────────────┐
│                    SISTEMA CASE MANAGEMENT                     │
├─────────────────┬───────────────────────────┬───────────────────┤
│   MÓDULO CASOS  │    MÓDULO HELPDESK        │  MÓDULOS ADMIN    │
│                 │                           │                   │
│ ┌─────────────┐ │ ┌─────────────────────────┐ │ ┌─────────────┐ │
│ │    Cases    │◄┼►│       Tickets           │ │ │    Users    │ │
│ │             │ │ │                         │ │ │             │ │
│ │ CaseControl │◄┼►│    Chat Messages        │ │ │    Roles    │ │
│ │             │ │ │                         │ │ │             │ │
│ │    Notes    │◄┼►│    SLA Tracking         │ │ │   Archive   │ │
│ │             │ │ │                         │ │ │             │ │
│ │    Todos    │◄┼►│    Escalations          │ │ │  Cleanup    │ │
│ └─────────────┘ │ └─────────────────────────┘ │ └─────────────┘ │
└─────────────────┴───────────────────────────┴───────────────────┘
                              │
                    ┌─────────▼─────────┐
                    │   SHARED LAYER    │
                    │                   │
                    │  • Supabase DB    │
                    │  • Authentication │
                    │  • RLS Policies   │
                    │  • Realtime       │
                    │  • File Storage   │
                    └───────────────────┘
```

**12.1.2 Puntos de Integración**

**a) Base de Datos Compartida**
- Utiliza la misma instancia de Supabase PostgreSQL
- Comparte tablas de usuarios (`user_profiles`)
- Reutiliza sistema de roles existente
- Aprovecha políticas RLS establecidas

**b) Autenticación Unificada**
- Extiende roles existentes con permisos HELPDESK
- Mantiene sesión única entre módulos
- Reutiliza componentes de autenticación (`AuthForm`, `ProtectedRoute`)

**c) Interfaz de Usuario Cohesiva**
- Integra con layout existente (`Layout.tsx`)
- Utiliza sistema de temas compartido (`themeStore.ts`)
- Aprovecha componentes base (`Button`, `Input`, `Modal`, `Select`)

**d) Sistema de Notificaciones Integrado**
- Extiende componente `NotificationSystem` existente
- Reutiliza infraestructura de Supabase Realtime
- Integra con bandeja de notificaciones unificada
- Comparte políticas RLS para seguridad

12.2 Reutilización de Componentes Existentes

**12.2.1 Componentes Base Reutilizados**
```typescript
// Componentes del sistema actual que HELPDESK aprovecha
import { Layout } from '../components/Layout';
import { Button } from '../components/Button';
import { Input } from '../components/Input';
import { Select } from '../components/Select';
import { Modal } from '../components/Modal';
import { LoadingSpinner } from '../components/LoadingSpinner';
import { ConfirmationModal } from '../components/ConfirmationModal';
import { NotificationSystem } from '../components/NotificationSystem';
import { ThemeToggle } from '../components/ThemeToggle';
import { PageWrapper } from '../components/PageWrapper';

// Hooks compartidos
import { useAuth } from '../hooks/useAuth';
import { usePermissions } from '../hooks/usePermissions';
import { useUsers } from '../hooks/useUsers';
import { useRoles } from '../hooks/useRoles';

// Stores compartidos
import { useThemeStore } from '../stores/themeStore';

// Utilidades compartidas
import { supabase } from '../lib/supabase';
import { validateInput } from '../lib/validations';
```

**12.2.2 Extensión del Sistema de Navegación**
```typescript
// Extensión de Layout.tsx para incluir navegación HELPDESK
const navigationItems = [
  // Navegación existente
  { name: 'Dashboard', href: '/dashboard', icon: HomeIcon },
  { name: 'Casos', href: '/cases', icon: FolderIcon },
  { name: 'Notas', href: '/notes', icon: DocumentTextIcon },
  { name: 'Todos', href: '/todos', icon: CheckCircleIcon },
  
  // Nueva navegación HELPDESK
  {
    name: 'HELPDESK',
    icon: ChatBubbleLeftRightIcon,
    children: [
      { name: 'Dashboard', href: '/helpdesk/dashboard' },
      { name: 'Tickets', href: '/helpdesk/tickets' },
      { name: 'Chat', href: '/helpdesk/chat' },
      { name: 'Reportes', href: '/helpdesk/reports' },
      { name: 'Configuración', href: '/helpdesk/config' }
    ]
  },
  
  // Navegación de administración (existente)
  { name: 'Archivo', href: '/archive', icon: ArchiveBoxIcon },
  { name: 'Admin', href: '/admin', icon: CogIcon }
];
```

12.3 Extensión del Sistema de Roles

**12.3.1 Nuevos Roles de HELPDESK**
```sql
-- Extensión de tabla roles existente
INSERT INTO roles (name, description, permissions) VALUES
('helpdesk_customer', 'Cliente de HELPDESK', ARRAY[
  'helpdesk.tickets.create',
  'helpdesk.tickets.view_own',
  'helpdesk.chat.send_messages',
  'helpdesk.chat.view_own'
]),
('helpdesk_agent_l1', 'Agente HELPDESK Nivel 1', ARRAY[
  'helpdesk.tickets.view_assigned',
  'helpdesk.tickets.update_status',
  'helpdesk.chat.send_messages',
  'helpdesk.chat.view_assigned',
  'helpdesk.escalation.create'
]),
('helpdesk_agent_l2', 'Agente HELPDESK Nivel 2', ARRAY[
  'helpdesk.tickets.view_team',
  'helpdesk.tickets.assign',
  'helpdesk.tickets.classify_to_case',
  'helpdesk.chat.send_internal',
  'helpdesk.sla.manage'
]),
('helpdesk_agent_l3', 'Agente HELPDESK Nivel 3', ARRAY[
  'helpdesk.tickets.view_all',
  'helpdesk.tickets.manage_all',
  'helpdesk.cases.create_from_ticket',
  'helpdesk.escalation.manage'
]),
('helpdesk_supervisor', 'Supervisor HELPDESK', ARRAY[
  'helpdesk.team.manage',
  'helpdesk.metrics.view_team',
  'helpdesk.reports.generate'
]),
('helpdesk_manager', 'Manager HELPDESK', ARRAY[
  'helpdesk.admin.full',
  'helpdesk.metrics.view_all',
  'helpdesk.config.manage',
  'helpdesk.reports.executive'
]);
```

**12.3.2 Integración con Sistema de Permisos Existente**
```typescript
// Extensión del hook usePermissions existente
export function useHelpdeskPermissions() {
  const { user, permissions } = usePermissions();
  
  return {
    // Permisos específicos de HELPDESK
    canCreateTickets: permissions.includes('helpdesk.tickets.create'),
    canViewAllTickets: permissions.includes('helpdesk.tickets.view_all'),
    canAssignTickets: permissions.includes('helpdesk.tickets.assign'),
    canClassifyToCases: permissions.includes('helpdesk.tickets.classify_to_case'),
    canCreateCasesFromTickets: permissions.includes('helpdesk.cases.create_from_ticket'),
    canSendInternalMessages: permissions.includes('helpdesk.chat.send_internal'),
    canManageSLA: permissions.includes('helpdesk.sla.manage'),
    canViewMetrics: permissions.includes('helpdesk.metrics.view_team') || 
                   permissions.includes('helpdesk.metrics.view_all'),
    canManageConfig: permissions.includes('helpdesk.config.manage'),
    
    // Métodos de utilidad
    isHelpdeskUser: () => user?.role?.name.startsWith('helpdesk_'),
    isHelpdeskAgent: () => user?.role?.name.startsWith('helpdesk_agent_'),
    isHelpdeskSupervisor: () => ['helpdesk_supervisor', 'helpdesk_manager'].includes(user?.role?.name),
    getHelpdeskLevel: () => {
      if (user?.role?.name === 'helpdesk_agent_l1') return 1;
      if (user?.role?.name === 'helpdesk_agent_l2') return 2;
      if (user?.role?.name === 'helpdesk_agent_l3') return 3;
      return 0;
    }
  };
}
```

12.4 Sincronización de Datos

**12.4.1 Flujo de Conversión Ticket → Caso**
```typescript
// Servicio de integración que conecta ambos módulos
class TicketCaseIntegrationService {
  async convertTicketToCase(ticketId: string, classification: CaseClassification): Promise<Case> {
    const ticket = await this.helpdeskService.getTicket(ticketId);
    
    // Reutilizar la lógica existente de creación de casos
    const caseData: CreateCaseData = {
      numeroCaso: await this.generateCaseNumber(), // Reutiliza función existente
      descripcion: `[HELPDESK #${ticket.ticketNumber}] ${ticket.subject}\n\n${ticket.description}`,
      fecha: new Date().toISOString().split('T')[0],
      origenId: await this.getHelpdeskOriginId(), // Nuevo origen "HELPDESK"
      aplicacionId: classification.applicationId,
      
      // Reutilizar sistema de clasificación existente
      historialCaso: classification.historialCaso,
      conocimientoModulo: classification.conocimientoModulo,
      manipulacionDatos: classification.manipulacionDatos,
      claridadDescripcion: classification.claridadDescripcion,
      causaFallo: classification.causaFallo,
      userId: ticket.assignedAgentId
    };
    
    // Usar funciones de validación existentes
    caseData.puntuacion = calcularPuntuacion(caseData); // Función existente
    caseData.clasificacion = clasificarCaso(caseData.puntuacion); // Función existente
    
    // Crear caso usando servicio existente
    const createdCase = await this.casesService.createCase(caseData);
    
    // Crear vínculo en tabla de integración
    await this.createTicketCaseLink(ticketId, createdCase.id);
    
    // Sincronizar notas del chat como notas del caso
    await this.syncChatToNotes(ticketId, createdCase.id);
    
    return createdCase;
  }
  
  private async syncChatToNotes(ticketId: string, caseId: string): Promise<void> {
    const chatMessages = await this.helpdeskService.getChatMessages(ticketId);
    
    for (const message of chatMessages) {
      if (!message.isInternal) { // Solo mensajes no internos
        await this.notesService.createNote({
          caseId: caseId,
          titulo: `Chat HELPDESK - ${message.sender.name}`,
          contenido: message.content,
          usuarioId: message.senderId,
          fechaCreacion: message.createdAt
        });
      }
    }
  }
}
```

**12.4.2 Sincronización Bidireccional**
```typescript
// Listener que mantiene sincronizados los estados
class StateSyncService {
  constructor() {
    this.setupRealtimeSync();
  }
  
  private setupRealtimeSync(): void {
    // Escuchar cambios en casos para actualizar tickets vinculados
    supabase
      .channel('case_status_sync')
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'case_control'
      }, async (payload) => {
        await this.syncCaseStatusToTicket(payload.new);
      })
      .subscribe();
    
    // Escuchar cambios en tickets para actualizar casos vinculados
    supabase
      .channel('ticket_status_sync')
      .on('postgres_changes', {
        event: 'UPDATE',
        schema: 'public',
        table: 'helpdesk_tickets'
      }, async (payload) => {
        await this.syncTicketStatusToCase(payload.new);
      })
      .subscribe();
  }
}
```

12.5 Dashboard Unificado

**12.5.1 Extensión del Dashboard Principal**
```typescript
// Integración de widgets HELPDESK en dashboard existente
const DashboardPage = () => {
  const { user } = useAuth();
  const { isHelpdeskUser } = useHelpdeskPermissions();
  
  return (
    <PageWrapper title="Dashboard">
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
        
        {/* Widgets existentes */}
        <CasesMetricsWidget />
        <NotesQuickAccess />
        <TodosSummary />
        
        {/* Nuevos widgets HELPDESK (condicionales) */}
        {isHelpdeskUser && (
          <>
            <HelpdeskSLAWidget />
            <HelpdeskTicketsWidget />
            <HelpdeskChatActivity />
          </>
        )}
        
        {/* Widget de integración */}
        <CasesHelpdeskIntegrationWidget />
        
      </div>
    </PageWrapper>
  );
};
```

**12.5.2 Widget de Integración**
```typescript
const CasesHelpdeskIntegrationWidget = () => {
  const { data: integrationStats } = useQuery(['integration-stats'], 
    () => integrationService.getStats()
  );
  
  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6 shadow">
      <h3 className="text-lg font-semibold mb-4">
        Integración Casos ↔ HELPDESK
      </h3>
      
      <div className="space-y-3">
        <div className="flex justify-between">
          <span>Tickets convertidos a casos:</span>
          <span className="font-bold text-blue-600">
            {integrationStats?.ticketsToCase || 0}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span>Casos con tickets vinculados:</span>
          <span className="font-bold text-green-600">
            {integrationStats?.casesWithTickets || 0}
          </span>
        </div>
        
        <div className="flex justify-between">
          <span>Sincronizaciones hoy:</span>
          <span className="font-bold text-purple-600">
            {integrationStats?.syncToday || 0}
          </span>
        </div>
      </div>
      
      <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-600">
        <Link 
          to="/helpdesk/integration-report" 
          className="text-sm text-blue-600 hover:text-blue-800"
        >
          Ver reporte completo →
        </Link>
      </div>
    </div>
  );
};
```

12.6 Ventajas de la Integración

**12.6.1 Beneficios Técnicos**
- ✅ **Reutilización de Código**: 70% de componentes base reutilizados
- ✅ **Consistencia UI/UX**: Misma experiencia visual y de navegación
- ✅ **Base de Datos Unificada**: Sin duplicación de datos de usuarios
- ✅ **Seguridad Cohesiva**: Políticas RLS y permisos centralizados
- ✅ **Realtime Compartido**: Misma infraestructura de WebSockets

**12.6.2 Beneficios Operacionales**
- ✅ **Flujo Único**: Transición natural de tickets a casos complejos
- ✅ **Historial Completo**: Trazabilidad total de la interacción cliente
- ✅ **Equipos Especializados**: Cada nivel maneja su especialidad
- ✅ **Métricas Integradas**: Visión completa del pipeline de soporte
- ✅ **Escalación Inteligente**: Basada en complejidad real del problema

**12.6.3 Beneficios para el Usuario**
- ✅ **Experiencia Unificada**: Una sola aplicación, múltiples funcionalidades
- ✅ **Datos Sincronizados**: Información coherente en todos los módulos
- ✅ **Flujos Optimizados**: Menos clicks, más productividad
- ✅ **Aprendizaje Mínimo**: Interfaz familiar para usuarios existentes

12.7 Plan de Migración

**12.7.1 Estrategia de Adopción Gradual**
```
Fase 1: Preparación (Semana 1-2)
├── Backup completo de base de datos actual
├── Migración de roles y permisos
├── Testing de compatibilidad
└── Capacitación inicial del equipo

Fase 2: Piloto Controlado (Semana 3-4)
├── Activación para 10% de usuarios (power users)
├── Monitoreo intensivo de performance
├── Recolección de feedback inicial
└── Ajustes basados en uso real

Fase 3: Rollout Gradual (Semana 5-8)
├── Expansión a 50% de usuarios
├── Activación de integraciones con casos
├── Training completo para todos los agentes
└── Optimización de flujos identificados

Fase 4: Adopción Completa (Semana 9-10)
├── Migración del 100% de usuarios
├── Activación de todas las funcionalidades
├── Monitoreo post-implementación
└── Documentación de lecciones aprendidas
```

---

*Este documento técnico establece las bases para la implementación exitosa del módulo HELPDESK, asegurando que el proyecto cumpla con los más altos estándares de calidad técnica y experiencia de usuario, mientras mantiene perfecta integración con el sistema existente.*

**Documento generado el 28 de Julio, 2025**
**Versión 1.0 - Especificación Técnica Completa**